{"meta":{"title":"HuanglnQuan.blog","subtitle":null,"description":null,"author":"Mac Huang","url":"http://yoursite.com"},"posts":[{"title":"CPU存储器，指令执行过程，中断处理(简述)","date":"2018-11-20T15:02:32.000Z","path":"2018/11/20/CPU存储器，指令执行过程，中断处理-简述/","text":"CPU主要有：1.数据寄存器：数据寄存器主要用来保存操作数和运算结果等信息，从而节省了读取操作数所需占用总线和访问存储器的时间。2.变址寄存器：主要用于存放存储单元在段内的偏移量，用他们可以实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。3.指针存储器：主要用于访问堆栈内的存储单元，并且规定BP为基指针寄存器，用它可以直接存取堆栈中的数据，SP为堆栈指针寄存器，它只可以访问栈顶。（变址寄存器和指针寄存器作为通用寄存器也可以存储操作数和运算结果）4.段寄存器：段寄存器是根据内存分段的管理模式而设置的，内存单元的物理地址是有段寄存器的值和一个偏移量组合而成的，这样就可以用两个较少位数的值组合成一个可以访问较大物理空间的内存地址。5.指令寄存器：指令指针EIP和IP是存放下次将要执行的指令在代码段的偏移量，用来提供指令在存储器中的地址 一条指令的执行通常有五个步骤：取指令-&gt;指令译码-&gt;执行指令-&gt;访存取数-&gt;结果写回1.取指令：将一条指令从主存中读取到指令寄存器2.指令译码：由指令译码器按照预定的指令格式，对取回的指令进行解释和拆分，识别区分出不同的指令类别以及获取各种操作数的方法3.执行指令：完成指令所规定的各种操作4.访存取数：有时候一条指令可能会访问主存读取操作数，根据指令地址码从主存中取出数据。4.结果写回：一般把指令阶段运行后的结果存储到数据存储器中，方便以后的读取。 中断处理：当CPU执行一条指令的时候，如果此时有一个外设发出了中断请求，那么CPU就会在满足相应的情况下，发出中断相应信号并且关闭中断，表示不再接受另一个设备的中断，然后寻找发出中断信号的设备，并且保存CPU自己的程序计数器内容，转移到处理该中断源的中断服务程序。CPU再保存现场信息，设备服务以后将会回复现场信息。这些都完成了之后，就会继续开放中断并且返回到原来被中的的主程序的下一条命令。过程： 请求中断-&gt;中断相应-&gt;关闭中断-&gt;保护断点-&gt;中断源识别-&gt;保护现场-&gt;恢复现场-&gt;中断返回（保护现场：因为主程序和中断服务子程序都要使用CPU内部寄存器等资源，为了不让中断处理程序破坏主程序中寄存器的内容，要先把个寄存器的内容压入堆栈保护起来，再进入中断处理。）","permalink":"http://yoursite.com/2018/11/20/CPU存储器，指令执行过程，中断处理-简述/","categories":[],"tags":[]},{"title":"浅谈MVC架构","date":"2018-11-17T16:15:16.000Z","path":"2018/11/18/浅谈MVC架构/","text":"MVC代表着“model”、“view”、“controller”。使用MVC开发的web应用程序，对搜索引擎更加友好。Model：model基本上是一个C#和VB.net的类model可以被view和controller访问controller通过model向view传输数据view使用model在页面上显示数据View：view层主要是一些ASPX页面文件，不包括后台代码view中可以对所有的页面进行HTML生成和格式化view中可以只用内联代码进行一些动态渲染view中的ASPX请求，只能调用controller中的方法Controller：controller是MVC架构的核心controller基本上是一些主要继承了system.mvc.controller的C#或者VB.NET的类controller中的所有方法都是用来响应浏览器或者view的请求的controller通过model层来向view层的页面传输数据controller使用viewdata向view层传输数据1.浏览器请求用户在浏览器中输入一个网址：http://xxx.com/home/index/,就产生了一个浏览器请求2.Global.asax的作用，MVC路由这个网址首先被Global.asax文件中的application_start（）方法捕获并解释出控制器，方法和ID，此时控制器为home方法为index（）ID为空3.controller层与调用方法现在MVC在controller目录下查找home控制器的方法，不同的控制器中包含不同的方法。此时找到index（）方法，调用这个方法之后，返回一个纯字符串或者被view层展示的HTML代码4.调用view层调用view层会访问view目录下指定的ASPX页面，并且生成一个相应的HTML代码返回给浏览器","permalink":"http://yoursite.com/2018/11/18/浅谈MVC架构/","categories":[],"tags":[]},{"title":"多项式相加链表和线性表实现","date":"2018-11-16T04:50:04.000Z","path":"2018/11/16/多项式相加链表和线性表实现/","text":"线性表实现:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;const int MAX = 10000;int main()&#123; int arr[MAX]; for (int i = 0; i &lt; MAX; ++i) arr[i] = 0; int t=2, n, m; int co, exp, max = 0; cout&lt;&lt;\"请输入第一个多项式的项数:\"; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; cout&lt;&lt;\"请依次输入系数和指数：\"; cin &gt;&gt; co &gt;&gt; exp; if (exp &gt; max) max = exp; arr[exp] = co; &#125; cout&lt;&lt;\"\\n请输入第二个多项式的项数:\"; cin &gt;&gt; m; for (int i = 0; i &lt; m; ++i) &#123; cout&lt;&lt;\"请依次输入系数和指数：\"; cin &gt;&gt; co &gt;&gt; exp; if (exp &gt; max) max = exp; arr[exp] += co; &#125; cout&lt;&lt;\"\\n\"; for (int i = max; i &gt;= 0; --i) if (arr[i] != 0) &#123; cout &lt;&lt; arr[i] &lt;&lt;\"*x^\"&lt;&lt; i ; if(i!=0) cout&lt;&lt;\"+\"; &#125; return 0;&#125; 链表实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include &lt;limits.h&gt;#include &lt;math.h&gt;#include &lt;process.h&gt;using namespace std;typedef struct LNode&#123; int coef; int expn; struct LNode *next;&#125; LNode,*polynomail;void creatpolyn(polynomail &amp;p,int m)&#123; int i; int coef; int expn; polynomail s; p=(polynomail)malloc(sizeof(LNode)); p-&gt;next=NULL; for(i=1; i&lt;=m; ++i) &#123; s=(polynomail)malloc(sizeof(LNode)); cout&lt;&lt;\"请输入一元多项式的系数和指数:\"; cin&gt;&gt;coef&gt;&gt;expn; s-&gt;coef=coef; s-&gt;expn=expn; s-&gt;next=p-&gt;next; p-&gt;next=s; &#125;&#125;polynomail addpolyn(polynomail &amp;pa,polynomail &amp;pb)&#123; polynomail c,pc; pc=(polynomail)malloc(sizeof(LNode)); pc-&gt;next=NULL; pa=pa-&gt;next; pb=pb-&gt;next; while(pa &amp;&amp; pb) &#123; if((pa-&gt;expn)==(pb-&gt;expn)) &#123; c=(polynomail)malloc(sizeof(LNode)); c-&gt;expn=pa-&gt;expn; c-&gt;coef=((pa-&gt;coef)+(pb-&gt;coef)); pa=pa-&gt;next; pb=pb-&gt;next; &#125; else if((pa-&gt;expn)&gt;(pb-&gt;expn)) &#123; c=(polynomail)malloc(sizeof(LNode)); c-&gt;expn=pb-&gt;expn; c-&gt;coef=pb-&gt;coef; pb=pb-&gt;next; &#125; else &#123; c=(polynomail)malloc(sizeof(LNode)); c-&gt;expn=pa-&gt;expn; c-&gt;coef=pa-&gt;coef; pa=pa-&gt;next; &#125; c-&gt;next=pc-&gt;next; pc-&gt;next=c; &#125; if(!pa &amp;&amp; pb) &#123; while(c-&gt;next!=NULL) &#123; c=c-&gt;next; &#125; c-&gt;next=pb; &#125; if(!pb &amp;&amp; pa) &#123; while(c-&gt;next!=NULL) &#123; c=c-&gt;next; &#125; c-&gt;next=pa; &#125; return pc;&#125;void printpolyn(polynomail &amp;p)&#123; while(p-&gt;next!=NULL) &#123; p=p-&gt;next; cout&lt;&lt;p-&gt;coef&lt;&lt;\"*X^\"&lt;&lt;p-&gt;expn; if(p-&gt;next!=NULL) cout&lt;&lt;\"+\"; &#125;&#125;int main()&#123; int n,m; polynomail pa,pb,pc; cout&lt;&lt;\"请输入一元多项式S1的项数:\"; scanf(\"%d\",&amp;n); creatpolyn(pa,n); cout&lt;&lt;\"请输入一元多项式S2的项数:\"; scanf(\"%d\",&amp;m); creatpolyn(pb,m); pc=addpolyn(pa,pb); cout&lt;&lt;\"\\n结果是:S1+S2= \"; printpolyn(pc);&#125;","permalink":"http://yoursite.com/2018/11/16/多项式相加链表和线性表实现/","categories":[],"tags":[]},{"title":"从浏览器输入url到显示网页发生了什么（简要过程）","date":"2018-11-15T13:39:42.000Z","path":"2018/11/15/从浏览器输入url到显示网页发生了什么（简要过程）/","text":"1.输入url2.应用层dns对域名进行解析，现在本地找有没有相应的IP地址，如果有就返回，没有就请求上级dns3.应用层客户端发送http请求4.传输层传输报文5.网络层IP协议查询MAC地址6.数据发送到数据链路层，服务器接收数据7.服务器响应请求返回相应文件8.页面渲染","permalink":"http://yoursite.com/2018/11/15/从浏览器输入url到显示网页发生了什么（简要过程）/","categories":[],"tags":[]},{"title":"内存中堆、栈和静态存储区的用法","date":"2018-11-15T07:42:14.000Z","path":"2018/11/15/that/","text":"1.堆堆中存储的全部是对象，每个对象都包含一个与之对应的class，不存储基本类型和对象的引用。在java JVM中只有一个堆区，且该堆区被所有线程共享。堆一般由程序员进行分配和释放。2.栈栈中存储的是基础数据类型和自定义对象的引用，内存中由多个栈区，每个线程都拥有属于他自己的一个栈区，并且栈区中的所有成员都是私有的，不能被其他线程的其他栈所访问。栈分为三个部分：基本类型变量区，执行环境上下文，操作指令区。栈是由系统编译器自行分配的。3.静态存储区存储所有的class和static变量，包含的都是程序中永远唯一的元素，他跟堆一样也是被所有线程所共享的。全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域中，未初始化的全局变量和静态变量在相邻的一块区域最有效率算2*8应该是移位运算吧，2左移三位？2&lt;&lt;3，这样应该不会占内存","permalink":"http://yoursite.com/2018/11/15/that/","categories":[],"tags":[]},{"title":"java关键字static、final、this、super总结","date":"2018-11-15T07:41:05.000Z","path":"2018/11/15/java关键字static、final、this、super总结/","text":"用static声明一个变量或方法，表示它是静态的，在之后可以对变量进行改变或者对静态方法进行重写，但是final表示最终的，由final声明的变量不能被重新赋值，方法不能被重写重构，final类不能被其他类所继承。 this和super一般在构造方法中比较常用(this一般用在该类的方法或者构造函数当中，而super一般用在一个继承了其他类的子类的方法或者构造方法中)，this可以调用该类的成员变量或者成员方法，并且可以在方法的任何位置使用，而super则是能对该类的父类的成员变量或方法进行调用，并且要调用super关键字必须在每个方法中的第一行进行调用","permalink":"http://yoursite.com/2018/11/15/java关键字static、final、this、super总结/","categories":[],"tags":[]},{"title":"Hello World","date":"2018-11-11T02:54:32.953Z","path":"2018/11/11/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","permalink":"http://yoursite.com/2018/11/11/hello-world/","categories":[],"tags":[]}]}