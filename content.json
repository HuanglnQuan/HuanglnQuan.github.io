{"meta":{"title":"HuanglnQuan.blog","subtitle":null,"description":null,"author":"Mac Huang","url":"http://yoursite.com"},"posts":[{"title":"多项式相加链表和线性表实现","date":"2018-11-16T04:50:04.000Z","path":"2018/11/16/多项式相加链表和线性表实现/","text":"线性表实现:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;const int MAX = 10000;int main()&#123; int arr[MAX]; for (int i = 0; i &lt; MAX; ++i) arr[i] = 0; int t=2, n, m; int co, exp, max = 0; cout&lt;&lt;\"请输入第一个多项式的项数:\"; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; cout&lt;&lt;\"请依次输入系数和指数：\"; cin &gt;&gt; co &gt;&gt; exp; if (exp &gt; max) max = exp; arr[exp] = co; &#125; cout&lt;&lt;\"\\n请输入第二个多项式的项数:\"; cin &gt;&gt; m; for (int i = 0; i &lt; m; ++i) &#123; cout&lt;&lt;\"请依次输入系数和指数：\"; cin &gt;&gt; co &gt;&gt; exp; if (exp &gt; max) max = exp; arr[exp] += co; &#125; cout&lt;&lt;\"\\n\"; for (int i = max; i &gt;= 0; --i) if (arr[i] != 0) &#123; cout &lt;&lt; arr[i] &lt;&lt;\"*x^\"&lt;&lt; i ; if(i!=0) cout&lt;&lt;\"+\"; &#125; return 0;&#125; 链表实现:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;const int MAX = 10000;int main()&#123; int arr[MAX]; for (int i = 0; i &lt; MAX; ++i) arr[i] = 0; int t=2, n, m; int co, exp, max = 0; cout&lt;&lt;\"请输入第一个多项式的项数:\"; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; cout&lt;&lt;\"请依次输入系数和指数：\"; cin &gt;&gt; co &gt;&gt; exp; if (exp &gt; max) max = exp; arr[exp] = co; &#125; cout&lt;&lt;\"\\n请输入第二个多项式的项数:\"; cin &gt;&gt; m; for (int i = 0; i &lt; m; ++i) &#123; cout&lt;&lt;\"请依次输入系数和指数：\"; cin &gt;&gt; co &gt;&gt; exp; if (exp &gt; max) max = exp; arr[exp] += co; &#125; cout&lt;&lt;\"\\n\"; for (int i = max; i &gt;= 0; --i) if (arr[i] != 0) &#123; cout &lt;&lt; arr[i] &lt;&lt;\"*x^\"&lt;&lt; i ; if(i!=0) cout&lt;&lt;\"+\"; &#125; return 0;&#125;","permalink":"http://yoursite.com/2018/11/16/多项式相加链表和线性表实现/","categories":[],"tags":[]},{"title":"从浏览器输入url到显示网页发生了什么（简要过程）","date":"2018-11-15T13:39:42.000Z","path":"2018/11/15/从浏览器输入url到显示网页发生了什么（简要过程）/","text":"1.输入url2.应用层dns对域名进行解析，现在本地找有没有相应的IP地址，如果有就返回，没有就请求上级dns3.应用层客户端发送http请求4.传输层传输报文5.网络层IP协议查询MAC地址6.数据发送到数据链路层，服务器接收数据7.服务器响应请求返回相应文件8.页面渲染","permalink":"http://yoursite.com/2018/11/15/从浏览器输入url到显示网页发生了什么（简要过程）/","categories":[],"tags":[]},{"title":"内存中堆、栈和静态存储区的用法","date":"2018-11-15T07:42:14.000Z","path":"2018/11/15/that/","text":"1.堆堆中存储的全部是对象，每个对象都包含一个与之对应的class，不存储基本类型和对象的引用。在java JVM中只有一个堆区，且该堆区被所有线程共享。堆一般由程序员进行分配和释放。2.栈栈中存储的是基础数据类型和自定义对象的引用，内存中由多个栈区，每个线程都拥有属于他自己的一个栈区，并且栈区中的所有成员都是私有的，不能被其他线程的其他栈所访问。栈分为三个部分：基本类型变量区，执行环境上下文，操作指令区。栈是由系统编译器自行分配的。3.静态存储区存储所有的class和static变量，包含的都是程序中永远唯一的元素，他跟堆一样也是被所有线程所共享的。全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域中，未初始化的全局变量和静态变量在相邻的一块区域最有效率算2*8应该是移位运算吧，2左移三位？2&lt;&lt;3，这样应该不会占内存","permalink":"http://yoursite.com/2018/11/15/that/","categories":[],"tags":[]},{"title":"java关键字static、final、this、super总结","date":"2018-11-15T07:41:05.000Z","path":"2018/11/15/java关键字static、final、this、super总结/","text":"用static声明一个变量或方法，表示它是静态的，在之后可以对变量进行改变或者对静态方法进行重写，但是final表示最终的，由final声明的变量不能被重新赋值，方法不能被重写重构，final类不能被其他类所继承。 this和super一般在构造方法中比较常用(this一般用在该类的方法或者构造函数当中，而super一般用在一个继承了其他类的子类的方法或者构造方法中)，this可以调用该类的成员变量或者成员方法，并且可以在方法的任何位置使用，而super则是能对该类的父类的成员变量或方法进行调用，并且要调用super关键字必须在每个方法中的第一行进行调用","permalink":"http://yoursite.com/2018/11/15/java关键字static、final、this、super总结/","categories":[],"tags":[]},{"title":"Hello World","date":"2018-11-11T02:54:32.953Z","path":"2018/11/11/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","permalink":"http://yoursite.com/2018/11/11/hello-world/","categories":[],"tags":[]}]}