{"meta":{"title":"HuanglnQuan.blog","subtitle":null,"description":null,"author":"Mac Huang","url":"http://yoursite.com"},"posts":[{"title":"浅谈MVC架构","date":"2018-11-17T16:15:16.000Z","path":"2018/11/18/浅谈MVC架构/","text":"MVC代表着“model”、“view”、“controller”。使用MVC开发的web应用程序，对搜索引擎更加友好。Model：model基本上是一个C#和VB.net的类model可以被view和controller访问controller通过model向view传输数据view使用model在页面上显示数据View：view层主要是一些ASPX页面文件，不包括后台代码view中可以对所有的页面进行HTML生成和格式化view中可以只用内联代码进行一些动态渲染view中的ASPX请求，只能调用controller中的方法Controller：controller是MVC架构的核心controller基本上是一些主要继承了system.mvc.controller的C#或者VB.NET的类controller中的所有方法都是用来响应浏览器或者view的请求的controller通过model层来向view层的页面传输数据controller使用viewdata向view层传输数据1.浏览器请求用户在浏览器中输入一个网址：http://xxx.com/home/index/,就产生了一个浏览器请求2.Global.asax的作用，MVC路由这个网址首先被Global.asax文件中的application_start（）方法捕获并解释出控制器，方法和ID，此时控制器为home方法为index（）ID为空3.controller层与调用方法现在MVC在controller目录下查找home控制器的方法，不同的控制器中包含不同的方法。此时找到index（）方法，调用这个方法之后，返回一个纯字符串或者被view层展示的HTML代码4.调用view层调用view层会访问view目录下指定的ASPX页面，并且生成一个相应的HTML代码返回给浏览器","permalink":"http://yoursite.com/2018/11/18/浅谈MVC架构/","categories":[],"tags":[]},{"title":"多项式相加链表和线性表实现","date":"2018-11-16T04:50:04.000Z","path":"2018/11/16/多项式相加链表和线性表实现/","text":"线性表实现:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;const int MAX = 10000;int main()&#123; int arr[MAX]; for (int i = 0; i &lt; MAX; ++i) arr[i] = 0; int t=2, n, m; int co, exp, max = 0; cout&lt;&lt;\"请输入第一个多项式的项数:\"; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; cout&lt;&lt;\"请依次输入系数和指数：\"; cin &gt;&gt; co &gt;&gt; exp; if (exp &gt; max) max = exp; arr[exp] = co; &#125; cout&lt;&lt;\"\\n请输入第二个多项式的项数:\"; cin &gt;&gt; m; for (int i = 0; i &lt; m; ++i) &#123; cout&lt;&lt;\"请依次输入系数和指数：\"; cin &gt;&gt; co &gt;&gt; exp; if (exp &gt; max) max = exp; arr[exp] += co; &#125; cout&lt;&lt;\"\\n\"; for (int i = max; i &gt;= 0; --i) if (arr[i] != 0) &#123; cout &lt;&lt; arr[i] &lt;&lt;\"*x^\"&lt;&lt; i ; if(i!=0) cout&lt;&lt;\"+\"; &#125; return 0;&#125; 链表实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include &lt;limits.h&gt;#include &lt;math.h&gt;#include &lt;process.h&gt;using namespace std;typedef struct LNode&#123; int coef; int expn; struct LNode *next;&#125; LNode,*polynomail;void creatpolyn(polynomail &amp;p,int m)&#123; int i; int coef; int expn; polynomail s; p=(polynomail)malloc(sizeof(LNode)); p-&gt;next=NULL; for(i=1; i&lt;=m; ++i) &#123; s=(polynomail)malloc(sizeof(LNode)); cout&lt;&lt;\"请输入一元多项式的系数和指数:\"; cin&gt;&gt;coef&gt;&gt;expn; s-&gt;coef=coef; s-&gt;expn=expn; s-&gt;next=p-&gt;next; p-&gt;next=s; &#125;&#125;polynomail addpolyn(polynomail &amp;pa,polynomail &amp;pb)&#123; polynomail c,pc; pc=(polynomail)malloc(sizeof(LNode)); pc-&gt;next=NULL; pa=pa-&gt;next; pb=pb-&gt;next; while(pa &amp;&amp; pb) &#123; if((pa-&gt;expn)==(pb-&gt;expn)) &#123; c=(polynomail)malloc(sizeof(LNode)); c-&gt;expn=pa-&gt;expn; c-&gt;coef=((pa-&gt;coef)+(pb-&gt;coef)); pa=pa-&gt;next; pb=pb-&gt;next; &#125; else if((pa-&gt;expn)&gt;(pb-&gt;expn)) &#123; c=(polynomail)malloc(sizeof(LNode)); c-&gt;expn=pb-&gt;expn; c-&gt;coef=pb-&gt;coef; pb=pb-&gt;next; &#125; else &#123; c=(polynomail)malloc(sizeof(LNode)); c-&gt;expn=pa-&gt;expn; c-&gt;coef=pa-&gt;coef; pa=pa-&gt;next; &#125; c-&gt;next=pc-&gt;next; pc-&gt;next=c; &#125; if(!pa &amp;&amp; pb) &#123; while(c-&gt;next!=NULL) &#123; c=c-&gt;next; &#125; c-&gt;next=pb; &#125; if(!pb &amp;&amp; pa) &#123; while(c-&gt;next!=NULL) &#123; c=c-&gt;next; &#125; c-&gt;next=pa; &#125; return pc;&#125;void printpolyn(polynomail &amp;p)&#123; while(p-&gt;next!=NULL) &#123; p=p-&gt;next; cout&lt;&lt;p-&gt;coef&lt;&lt;\"*X^\"&lt;&lt;p-&gt;expn; if(p-&gt;next!=NULL) cout&lt;&lt;\"+\"; &#125;&#125;int main()&#123; int n,m; polynomail pa,pb,pc; cout&lt;&lt;\"请输入一元多项式S1的项数:\"; scanf(\"%d\",&amp;n); creatpolyn(pa,n); cout&lt;&lt;\"请输入一元多项式S2的项数:\"; scanf(\"%d\",&amp;m); creatpolyn(pb,m); pc=addpolyn(pa,pb); cout&lt;&lt;\"\\n结果是:S1+S2= \"; printpolyn(pc);&#125;","permalink":"http://yoursite.com/2018/11/16/多项式相加链表和线性表实现/","categories":[],"tags":[]},{"title":"从浏览器输入url到显示网页发生了什么（简要过程）","date":"2018-11-15T13:39:42.000Z","path":"2018/11/15/从浏览器输入url到显示网页发生了什么（简要过程）/","text":"1.输入url2.应用层dns对域名进行解析，现在本地找有没有相应的IP地址，如果有就返回，没有就请求上级dns3.应用层客户端发送http请求4.传输层传输报文5.网络层IP协议查询MAC地址6.数据发送到数据链路层，服务器接收数据7.服务器响应请求返回相应文件8.页面渲染","permalink":"http://yoursite.com/2018/11/15/从浏览器输入url到显示网页发生了什么（简要过程）/","categories":[],"tags":[]},{"title":"内存中堆、栈和静态存储区的用法","date":"2018-11-15T07:42:14.000Z","path":"2018/11/15/that/","text":"1.堆堆中存储的全部是对象，每个对象都包含一个与之对应的class，不存储基本类型和对象的引用。在java JVM中只有一个堆区，且该堆区被所有线程共享。堆一般由程序员进行分配和释放。2.栈栈中存储的是基础数据类型和自定义对象的引用，内存中由多个栈区，每个线程都拥有属于他自己的一个栈区，并且栈区中的所有成员都是私有的，不能被其他线程的其他栈所访问。栈分为三个部分：基本类型变量区，执行环境上下文，操作指令区。栈是由系统编译器自行分配的。3.静态存储区存储所有的class和static变量，包含的都是程序中永远唯一的元素，他跟堆一样也是被所有线程所共享的。全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域中，未初始化的全局变量和静态变量在相邻的一块区域最有效率算2*8应该是移位运算吧，2左移三位？2&lt;&lt;3，这样应该不会占内存","permalink":"http://yoursite.com/2018/11/15/that/","categories":[],"tags":[]},{"title":"java关键字static、final、this、super总结","date":"2018-11-15T07:41:05.000Z","path":"2018/11/15/java关键字static、final、this、super总结/","text":"用static声明一个变量或方法，表示它是静态的，在之后可以对变量进行改变或者对静态方法进行重写，但是final表示最终的，由final声明的变量不能被重新赋值，方法不能被重写重构，final类不能被其他类所继承。 this和super一般在构造方法中比较常用(this一般用在该类的方法或者构造函数当中，而super一般用在一个继承了其他类的子类的方法或者构造方法中)，this可以调用该类的成员变量或者成员方法，并且可以在方法的任何位置使用，而super则是能对该类的父类的成员变量或方法进行调用，并且要调用super关键字必须在每个方法中的第一行进行调用","permalink":"http://yoursite.com/2018/11/15/java关键字static、final、this、super总结/","categories":[],"tags":[]},{"title":"Hello World","date":"2018-11-11T02:54:32.953Z","path":"2018/11/11/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","permalink":"http://yoursite.com/2018/11/11/hello-world/","categories":[],"tags":[]}]}