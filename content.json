{"meta":{"title":"HuanglnQuan.blog","subtitle":null,"description":null,"author":"Mac Huang","url":"http://yoursite.com"},"posts":[{"title":"最小生成树Prim算法","date":"2018-11-24T08:51:59.000Z","path":"2018/11/24/最小生成树Prim算法/","text":"最小生成树Prim算法实现，输出最小生成树总路径长： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;int mapcost[1024][1024]; //存储输入的地图信息，每条边的权值using namespace std;int lowcost[1024],book[1024]; //lowcost为辅助数组，动态记录从源点到个点的最短距离，book数组用来标记一个点是否在已生成树中int prim(int n) //prim算法，参数为点的个数&#123; int sum=0; for(int i=1; i&lt;=n; i++) //lowcost数组初始化，每个点的lowcost值为用户输入信息中从源点（源点为1）到个点的距离 &#123; lowcost[i]=mapcost[1][i]; &#125; book[1]=1; //从1开始，把1收入到生成树中 int mins,index,t; //mins用来记录最小值，index记录lowcost最小值的点 for(int i=1; i&lt;n; i++) &#123; mins=999; for(t=1; t&lt;=n; t++) //寻找已生成树中能够到达的权值最小的边的点 &#123; if(book[t]==0&amp;&amp;mins&gt;lowcost[t]) &#123; mins=lowcost[t]; index=t; &#125; &#125; sum+=lowcost[index]; //记录路径长度 book[index]=1; //将index点加入到生成树中 for(int g=1; g&lt;=n; g++) //因为生成树中多了一个节点index，所有需要重新调整lowcost数组，lowcost数组始终记录从已生成树中到其余个点的最短距离 &#123; if(book[g]==0&amp;&amp;mapcost[index][g]&lt;lowcost[g]) &#123; lowcost[g]=mapcost[index][g]; &#125; &#125; &#125; for(int j=1;j&lt;=n;j++) //处理未连通的情况 &#123; if(book[j]==0) return -1; &#125; return sum;&#125;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; if(m&lt;n-1) //不能连通图的情况 cout&lt;&lt;-1; else &#123; int x,y,z; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) //初始化mapcost数组 mapcost[i][j]=999; &#125; for(int i=0; i&lt;m; i++) //因为是无向图，所以需要xy，yx赋两次值 &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; mapcost[x][y]=z; mapcost[y][x]=z; &#125; int re=prim(n); cout&lt;&lt;re; &#125; return 0;&#125;","permalink":"http://yoursite.com/2018/11/24/最小生成树Prim算法/","categories":[],"tags":[]},{"title":"简述网桥、交换机、路由器、网关在网络中的作用","date":"2018-11-24T08:32:20.000Z","path":"2018/11/24/简述网桥、交换机、路由器、网关在网络中的作用/","text":"1.网桥 网桥是一个局域网与另一个局域网之间建立连接的桥梁，网桥属于数据链路层设备，它的作用是扩展网络和通信手段，在各种传输介质中转发数据信号，扩展网络的距离，同时又有选择的将现有地址的信号从一个传输介质发送到另一个传输介质，并且能够有效的限制两个介质系统中无关紧要的通信，简单来说就是将两个局域网连接起来然后根据MAC地址来转发数据帧。 2.交换机 交换机也是工作在数据链路层，它比集线器智能，它能够分辨出数据帧中的源MAC地址和目的MAC地址，因此可以在任意两个端口间建立联系，在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧能够直接由源地址到达目的地址，交换机通过对信息进行重新生成，并且经过内部处理后转发至指定端口，具备自动寻址能力和交换作用，但是交换机不能读懂IP地址，它只知道MAC地址。交换机可以理解为高级的网桥，它是改进版的网桥，性能更好，交换机连接的是独立的计算机，而网桥连接的是LAN （交换机是使用硬件来完成以往网桥使用软件来完成过滤、学习和转发过程的任务，交换机的速度要比集线器快，因为它可以分辨出源MAC地址和目的MAC地址，可以在指定的任意两个端口之间建立联系，而不用像集线器一样把数据发送到所有端口，这样过滤降低了整个网络中的数据传输量，提高了效率，交换机还可以把网络拆解成网络分支，分割网络数据流，这样可以减少每个网络分支的数据信息流量而使得每个网络更加有效） 3.路由器 路由器工作在第三层网络层，它又比之前的交换机要聪明，因为它可以读懂数据中的IP地址，每当它接收到一个数据包，就会检查其中的IP地址，如果是本地的IP地址就不会理会，如果是其他网络的IP地址就会把数据包转发出本地网络。并且路由器使用专门的软件协议从逻辑上对整个网络进行划分。（一台支持IP协议的路由器可以把网络划分成多个子网络，只要指向特殊IP地址的网络流量才可以通过路由器，当IP子网中的一台主机发送IP分组给同一IP子网中的另一台主机时，它将直接把IP分组发送到网络上，对方就可以收到，但是如果是发送给一个不同子网络的主机时，他就要选择一个能够达到目的子网络的路由器，把IP分组发给它，然后再由该路由器把IP分组发送到目的地） 对于每一个接收到的数据包，路由器都会重新计算校验值，并且写入新的物理地址。网络中的设备用它们的网络地址互相通信。IP地址是与硬件无关的“逻辑”地址。Internet就是成千上万个IP子网通过路由器连接起来的国际性网络。路由器的主要工作就是为经过路由器的每个IP数据包寻找一条最佳传输路径，并将该数据有效的传送到目的站点，把数据传输到正确的网络。 4.网关 网关又称网间连接器，协议转换器。网关在网络层上实现网络互联，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连，网络既可以用于广域网互联也可以用于局域网互连。网关是一种充当转换重任的计算机系统或设备，使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器，它会对收到的信息都进行重新打包，以适应系统的需求。简单来说就是连接两个不同网络的接口。 1.交换机和路由器的区别？ 从应用上说： 交换机和路由器的使用中最大的区别莫过于路由器内部可实现拨号上网，然后通过共享给多台电脑同时上网，而交换机内部不具有拨号功能，但交换机的作用是将网络信号分流，以实现更多电脑连接共享上网。 大家可以这样认为，交换机可以将多台电脑连接起来，与交换机互连的电脑本身则具备了互相通信的功能，组建成了一个内部局域网，但需要访问互联网还需要有网络支持，因此交换机一端需要连接到路由器，路由器即可实现交换功能，还可以拨号，实现宽带连接，并将宽带资源分配个交换机使用，这样就实现了多台电脑共享上网。 从概念上说： 路由，是三层设备，有选择道路的作用。比如你去罗马，有很多路可以走，怎么走省钱省时间，就是路由要做的，解决你应该按照那条路走的问题。当然还有基于三层的其他功能。 交换机，是二层设备。他就像你家门前的如或者你们楼道，附近的住户都知道去几层几号怎么走。 举个例子说明路由器和交换机的配合：我要去找小明借电脑，小明说他不在家，叫我自己去拿吧，同时还告诉我他家的地址是XX路XX小区XX号（好比ip地址），我根据小明告诉我的地址找到了小明的家（路由器的功能，寻找路径）。我进门发现他家居然有10台电脑，哪台是借给我的那台呢？噢，原来小明还告诉我他要借给我的电脑的编号（MAC地址），那样我就可以根据编号找到相应的电脑了。 在上述的例子中，如果我没有路由器，我就不知道怎么去小明家，更不用说拿到电脑；如果我没有拿到所需的电脑编号，我也拿不到电脑，因为有十台电脑，我不能乱拿；有个特殊情况，如果小明家只有一台电脑呢？那我就不需要编号就可以确定拿哪台电脑，也就是不需要交换机。 2.为什么有时候还要在路由器的后面先接1台交换机再接计算机？ 路由器是可以直接接电脑等终端设备，为什么标准都是路由器接交换机然后再接电脑等终端，是因为路由器本来就是一个路由设备，用来选路的，不适合大量的数据交换，交换机是用来大量数据交换的，终端在内网的性质就是需要使用交换机，所以标准就是路由器地下接交换机的形式。一般是情况就是在路由器下面接交换机，路由器主要起数据转发，也就是寻址、路由的功能，交换机起到用户接入的目的。但是家用的路由器的话直接就接计算机就可以了，而不必考虑再接交换机。 原文：https://blog.csdn.net/qq_25606103/article/","permalink":"http://yoursite.com/2018/11/24/简述网桥、交换机、路由器、网关在网络中的作用/","categories":[],"tags":[]},{"title":"操作系统中的几种进程调度策略","date":"2018-11-23T13:42:57.000Z","path":"2018/11/23/操作系统中的几种进程调度策略/","text":"1.先来先服务调度算法：该算法即可以用与作业调度又可以用与进程调度，作业调度使用该算法便每次调度都从作业队列中选择一个或者多个处于队列最前面的作业，把他调入内存，为它分配资源，创建线程然后放入就绪队列，进程调度使用该算法便每次从就绪队列中选择一个最先进入队列的进程，让它开始运行 2.短作业短进程优先调度：作业调度使用该算法便从后备队列从选择一个或者多个预计运行时间最短的作业加入到内存中运行，进程调度使用该算法就是从就绪队列中选一个预计运行时间最短的让其开始运行 3.非抢占式优先权算法：优先权算法就是为每一个作业或者进程分配一个优先级，每次都优先开始优先级较高的作业或者线程。非抢占式优先权算法就是当系统把处理机分配给一个优先级最高的进程之后，该进程便会一直执行下去直到进程运行完或者某事件使该进程放弃处理机时，不会因为就绪队列中加入了一个优先级更高的进程而放弃执行该进程 4.抢占式优先权算法：就跟第3个差不多，只不过当原最高优先级进程运行时，如果就绪队列中加入了一个优先级更高的进程，系统就会停止原进程，让新的优先级最高的进程投入执行 5.高相应比优先调度算法：此算法与之前的优先权和短作业算法基本相似，只不过优先权的计算方法为（等待时间+要求服务时间）/要求服务时间，即每个进程的优先权会随等待被执行时间而改变，这样避免了一个作业或者进程因为预计执行时间太长而一直不被执行，每个作业的优先级随着等待时间增长而升高 6.多级反馈队列调度算法：该算法基于时间片轮转法，简单来说就是为每一个进程都分配一个时间片段，当执行一个进程的时间片用完了之后便把该进程放到就绪队列的最末尾，然后继续把时间片分配给下一个线程，使得每一个线程都可以被执行多级反馈就是设置了多个就绪队列，算是对前面几种算法的一个结合改进吧，并且每个就绪队列的优先级都不同，优先级高的所分配的时间片就长，反之则较低。假设第一队列中的一个进程在时间片内执行完了便会撤离系统，如果没有执行完便会被加入到第二队列的末尾，等待下一次执行，如果第二队列中分配的时间片内还是没有完成就加入到第三队列末尾，以此类推。","permalink":"http://yoursite.com/2018/11/23/操作系统中的几种进程调度策略/","categories":[],"tags":[]},{"title":"当一个线程进入一个synchronized方法之后，其他线程能否进入此对象的其他方法","date":"2018-11-23T13:38:51.000Z","path":"2018/11/23/当一个线程进入一个synchronized方法之后，其他线程能否进入此对象的其他方法/","text":"分为几种情况：1.其他方法前如果没有加synchronized关键字，就可以进入，因为其他的方法并没有被同步锁上锁，可以被正常访问 2.如果这个synchronized方法内部调用了wait，则可以进入其他synchronized方法，因为在方法中运行到wait时，该线程便退出了运行状态，对象的同步锁就被解开了 3.如果其他方法都加了synchronized方法并且该方法内部没有调用wait，则不能进入其他方法，同步锁的标志是一个对象，线程进入一个synchronized方法时，同步锁便被上锁了，包括该对象的所有其他synchronized方法 4.如果其他方法是static的，它用的同步锁是当前类的字节码，与非静态方法不能同步，所以可以进入其他静态方法。非静态方法可以使用this来进行同步，但是调用静态方法时，对象实例不一定被创建，所以不能使用this进行同步，而是使用一个class对象进行同步。所以两者同步锁的对象是不同的","permalink":"http://yoursite.com/2018/11/23/当一个线程进入一个synchronized方法之后，其他线程能否进入此对象的其他方法/","categories":[],"tags":[]},{"title":"计算机按下开机键后的简单启动过程","date":"2018-11-20T15:08:42.000Z","path":"2018/11/20/计算机按下开机键后的简单启动过程/","text":"第一阶段：BIOS BIOS（Basic Input/Output System）是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输入出的程序、开机后自检程序和系统自启动程序，它可以从CMOS中读写系统设置的具体信息，主要功能是为计算机提供最底层、最直接的硬件设置和控制。 BIOS程序首先检查计算机能否满足运行的基本条件即硬件自检POST（Power on self test），检测系统中的一些关键设备是否存在和能否正常工作，如内存和显卡等等，如果发现了一些致命的错误，就会喇叭发声来报告错误。然后BIOS把控制权交给下一阶段的启动程序，BIOS需要知道下一阶段的启动程序具体放在哪一个设备中，所以它需要一个外部设备的排序，优先转交控制权给排在前面的设备，这种排序叫做“启动顺序”。 第二阶段：主引导记录 BIOS按照启动顺序，把控制权交给排在第一位的储存设备，这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节，这最前面的512个字节就叫做“主引导记录”。 第三阶段：硬盘启动 这是计算机的控制权就要转交给硬盘的某个分区了。 第四阶段：操作系统分区中会记载操作系统的信息，然后控制权交给操作系统，操作系统的内核首先被载入内存，进而启动相关进程，计算机启动过程便完成了。","permalink":"http://yoursite.com/2018/11/20/计算机按下开机键后的简单启动过程/","categories":[],"tags":[]},{"title":"CPU存储器，指令执行过程，中断处理(简述)","date":"2018-11-20T15:02:32.000Z","path":"2018/11/20/CPU存储器，指令执行过程，中断处理-简述/","text":"CPU主要有：1.数据寄存器：数据寄存器主要用来保存操作数和运算结果等信息，从而节省了读取操作数所需占用总线和访问存储器的时间。2.变址寄存器：主要用于存放存储单元在段内的偏移量，用他们可以实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。3.指针存储器：主要用于访问堆栈内的存储单元，并且规定BP为基指针寄存器，用它可以直接存取堆栈中的数据，SP为堆栈指针寄存器，它只可以访问栈顶。（变址寄存器和指针寄存器作为通用寄存器也可以存储操作数和运算结果）4.段寄存器：段寄存器是根据内存分段的管理模式而设置的，内存单元的物理地址是有段寄存器的值和一个偏移量组合而成的，这样就可以用两个较少位数的值组合成一个可以访问较大物理空间的内存地址。5.指令寄存器：指令指针EIP和IP是存放下次将要执行的指令在代码段的偏移量，用来提供指令在存储器中的地址 一条指令的执行通常有五个步骤：取指令-&gt;指令译码-&gt;执行指令-&gt;访存取数-&gt;结果写回1.取指令：将一条指令从主存中读取到指令寄存器2.指令译码：由指令译码器按照预定的指令格式，对取回的指令进行解释和拆分，识别区分出不同的指令类别以及获取各种操作数的方法3.执行指令：完成指令所规定的各种操作4.访存取数：有时候一条指令可能会访问主存读取操作数，根据指令地址码从主存中取出数据。4.结果写回：一般把指令阶段运行后的结果存储到数据存储器中，方便以后的读取。 中断处理：当CPU执行一条指令的时候，如果此时有一个外设发出了中断请求，那么CPU就会在满足相应的情况下，发出中断相应信号并且关闭中断，表示不再接受另一个设备的中断，然后寻找发出中断信号的设备，并且保存CPU自己的程序计数器内容，转移到处理该中断源的中断服务程序。CPU再保存现场信息，设备服务以后将会回复现场信息。这些都完成了之后，就会继续开放中断并且返回到原来被中的的主程序的下一条命令。过程： 请求中断-&gt;中断相应-&gt;关闭中断-&gt;保护断点-&gt;中断源识别-&gt;保护现场-&gt;恢复现场-&gt;中断返回（保护现场：因为主程序和中断服务子程序都要使用CPU内部寄存器等资源，为了不让中断处理程序破坏主程序中寄存器的内容，要先把个寄存器的内容压入堆栈保护起来，再进入中断处理。）","permalink":"http://yoursite.com/2018/11/20/CPU存储器，指令执行过程，中断处理-简述/","categories":[],"tags":[]},{"title":"浅谈MVC架构","date":"2018-11-17T16:15:16.000Z","path":"2018/11/18/浅谈MVC架构/","text":"MVC代表着“model”、“view”、“controller”。使用MVC开发的web应用程序，对搜索引擎更加友好。Model：model基本上是一个C#和VB.net的类model可以被view和controller访问controller通过model向view传输数据view使用model在页面上显示数据View：view层主要是一些ASPX页面文件，不包括后台代码view中可以对所有的页面进行HTML生成和格式化view中可以只用内联代码进行一些动态渲染view中的ASPX请求，只能调用controller中的方法Controller：controller是MVC架构的核心controller基本上是一些主要继承了system.mvc.controller的C#或者VB.NET的类controller中的所有方法都是用来响应浏览器或者view的请求的controller通过model层来向view层的页面传输数据controller使用viewdata向view层传输数据1.浏览器请求用户在浏览器中输入一个网址：http://xxx.com/home/index/,就产生了一个浏览器请求2.Global.asax的作用，MVC路由这个网址首先被Global.asax文件中的application_start（）方法捕获并解释出控制器，方法和ID，此时控制器为home方法为index（）ID为空3.controller层与调用方法现在MVC在controller目录下查找home控制器的方法，不同的控制器中包含不同的方法。此时找到index（）方法，调用这个方法之后，返回一个纯字符串或者被view层展示的HTML代码4.调用view层调用view层会访问view目录下指定的ASPX页面，并且生成一个相应的HTML代码返回给浏览器","permalink":"http://yoursite.com/2018/11/18/浅谈MVC架构/","categories":[],"tags":[]},{"title":"多项式相加链表和线性表实现","date":"2018-11-16T04:50:04.000Z","path":"2018/11/16/多项式相加链表和线性表实现/","text":"线性表实现:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;const int MAX = 10000;int main()&#123; int arr[MAX]; for (int i = 0; i &lt; MAX; ++i) arr[i] = 0; int t=2, n, m; int co, exp, max = 0; cout&lt;&lt;\"请输入第一个多项式的项数:\"; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; cout&lt;&lt;\"请依次输入系数和指数：\"; cin &gt;&gt; co &gt;&gt; exp; if (exp &gt; max) max = exp; arr[exp] = co; &#125; cout&lt;&lt;\"\\n请输入第二个多项式的项数:\"; cin &gt;&gt; m; for (int i = 0; i &lt; m; ++i) &#123; cout&lt;&lt;\"请依次输入系数和指数：\"; cin &gt;&gt; co &gt;&gt; exp; if (exp &gt; max) max = exp; arr[exp] += co; &#125; cout&lt;&lt;\"\\n\"; for (int i = max; i &gt;= 0; --i) if (arr[i] != 0) &#123; cout &lt;&lt; arr[i] &lt;&lt;\"*x^\"&lt;&lt; i ; if(i!=0) cout&lt;&lt;\"+\"; &#125; return 0;&#125; 链表实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include &lt;limits.h&gt;#include &lt;math.h&gt;#include &lt;process.h&gt;using namespace std;typedef struct LNode&#123; int coef; int expn; struct LNode *next;&#125; LNode,*polynomail;void creatpolyn(polynomail &amp;p,int m)&#123; int i; int coef; int expn; polynomail s; p=(polynomail)malloc(sizeof(LNode)); p-&gt;next=NULL; for(i=1; i&lt;=m; ++i) &#123; s=(polynomail)malloc(sizeof(LNode)); cout&lt;&lt;\"请输入一元多项式的系数和指数:\"; cin&gt;&gt;coef&gt;&gt;expn; s-&gt;coef=coef; s-&gt;expn=expn; s-&gt;next=p-&gt;next; p-&gt;next=s; &#125;&#125;polynomail addpolyn(polynomail &amp;pa,polynomail &amp;pb)&#123; polynomail c,pc; pc=(polynomail)malloc(sizeof(LNode)); pc-&gt;next=NULL; pa=pa-&gt;next; pb=pb-&gt;next; while(pa &amp;&amp; pb) &#123; if((pa-&gt;expn)==(pb-&gt;expn)) &#123; c=(polynomail)malloc(sizeof(LNode)); c-&gt;expn=pa-&gt;expn; c-&gt;coef=((pa-&gt;coef)+(pb-&gt;coef)); pa=pa-&gt;next; pb=pb-&gt;next; &#125; else if((pa-&gt;expn)&gt;(pb-&gt;expn)) &#123; c=(polynomail)malloc(sizeof(LNode)); c-&gt;expn=pb-&gt;expn; c-&gt;coef=pb-&gt;coef; pb=pb-&gt;next; &#125; else &#123; c=(polynomail)malloc(sizeof(LNode)); c-&gt;expn=pa-&gt;expn; c-&gt;coef=pa-&gt;coef; pa=pa-&gt;next; &#125; c-&gt;next=pc-&gt;next; pc-&gt;next=c; &#125; if(!pa &amp;&amp; pb) &#123; while(c-&gt;next!=NULL) &#123; c=c-&gt;next; &#125; c-&gt;next=pb; &#125; if(!pb &amp;&amp; pa) &#123; while(c-&gt;next!=NULL) &#123; c=c-&gt;next; &#125; c-&gt;next=pa; &#125; return pc;&#125;void printpolyn(polynomail &amp;p)&#123; while(p-&gt;next!=NULL) &#123; p=p-&gt;next; cout&lt;&lt;p-&gt;coef&lt;&lt;\"*X^\"&lt;&lt;p-&gt;expn; if(p-&gt;next!=NULL) cout&lt;&lt;\"+\"; &#125;&#125;int main()&#123; int n,m; polynomail pa,pb,pc; cout&lt;&lt;\"请输入一元多项式S1的项数:\"; scanf(\"%d\",&amp;n); creatpolyn(pa,n); cout&lt;&lt;\"请输入一元多项式S2的项数:\"; scanf(\"%d\",&amp;m); creatpolyn(pb,m); pc=addpolyn(pa,pb); cout&lt;&lt;\"\\n结果是:S1+S2= \"; printpolyn(pc);&#125;","permalink":"http://yoursite.com/2018/11/16/多项式相加链表和线性表实现/","categories":[],"tags":[]},{"title":"从浏览器输入url到显示网页发生了什么（简要过程）","date":"2018-11-15T13:39:42.000Z","path":"2018/11/15/从浏览器输入url到显示网页发生了什么（简要过程）/","text":"1.输入url2.应用层dns对域名进行解析，现在本地找有没有相应的IP地址，如果有就返回，没有就请求上级dns3.应用层客户端发送http请求4.传输层传输报文5.网络层IP协议查询MAC地址6.数据发送到数据链路层，服务器接收数据7.服务器响应请求返回相应文件8.页面渲染","permalink":"http://yoursite.com/2018/11/15/从浏览器输入url到显示网页发生了什么（简要过程）/","categories":[],"tags":[]},{"title":"内存中堆、栈和静态存储区的用法","date":"2018-11-15T07:42:14.000Z","path":"2018/11/15/that/","text":"1.堆堆中存储的全部是对象，每个对象都包含一个与之对应的class，不存储基本类型和对象的引用。在java JVM中只有一个堆区，且该堆区被所有线程共享。堆一般由程序员进行分配和释放。2.栈栈中存储的是基础数据类型和自定义对象的引用，内存中由多个栈区，每个线程都拥有属于他自己的一个栈区，并且栈区中的所有成员都是私有的，不能被其他线程的其他栈所访问。栈分为三个部分：基本类型变量区，执行环境上下文，操作指令区。栈是由系统编译器自行分配的。3.静态存储区存储所有的class和static变量，包含的都是程序中永远唯一的元素，他跟堆一样也是被所有线程所共享的。全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域中，未初始化的全局变量和静态变量在相邻的一块区域最有效率算2*8应该是移位运算吧，2左移三位？2&lt;&lt;3，这样应该不会占内存","permalink":"http://yoursite.com/2018/11/15/that/","categories":[],"tags":[]},{"title":"java关键字static、final、this、super总结","date":"2018-11-15T07:41:05.000Z","path":"2018/11/15/java关键字static、final、this、super总结/","text":"用static声明一个变量或方法，表示它是静态的，在之后可以对变量进行改变或者对静态方法进行重写，但是final表示最终的，由final声明的变量不能被重新赋值，方法不能被重写重构，final类不能被其他类所继承。 this和super一般在构造方法中比较常用(this一般用在该类的方法或者构造函数当中，而super一般用在一个继承了其他类的子类的方法或者构造方法中)，this可以调用该类的成员变量或者成员方法，并且可以在方法的任何位置使用，而super则是能对该类的父类的成员变量或方法进行调用，并且要调用super关键字必须在每个方法中的第一行进行调用","permalink":"http://yoursite.com/2018/11/15/java关键字static、final、this、super总结/","categories":[],"tags":[]}]}