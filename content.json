{"meta":{"title":"HuanglnQuan.blog","subtitle":null,"description":null,"author":"Mac Huang","url":"http://yoursite.com"},"posts":[{"title":"简单理解动态代理与AOP","date":"2019-03-25T13:18:29.000Z","path":"2019/03/25/简单理解动态代理与AOP/","text":"简单理解动态代理与AOP今天在学习反射机制的时候，接触到了动态代理与AOP，一开始也不明天具体是什么意思，有什么用处，然后在网上看了各路大神的blog终于有了一点自己的体会 动态代理1.静态代理 &emsp;&emsp;所谓静态代理就是由程序员来编写或者特定工具自动的生成了源代码，在程序编译之前，所有的接口，被代理类，代理类等等都已经被确定下来了,程序运行之前，代理类的.class文件就已经生成了。2.动态代理 &emsp;&emsp;动态代理就是当程序运行时才会创建代理类，且确认代理类所需要代理的类。可以方便我们对代理类的函数进行一些加工和处理。并且动态代理可以解决一定程度上的代码冗余。你只需要创建一个代理类的对象便可以代理各种不同的类。 &emsp;&emsp;实现动态代理我们主要用到InvocationHandler接口和Proxy类 1. 首先我们需要创建一个代理类实现InvocationHandler接口 ##class myInvocationHandler implements InvocationHandler { Object obj;//这里表示你要代理的实际对象 public myInvocationHandler(Object obj) { this.obj = obj;//在创建该类的对象时需要为获取需要代理的对象 } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;you are using USC_Agency,you ought to pay for $1000.&quot;);//这里是你要对方法进行何种加工处理，可以写日志等等 method.invoke(obj, args); //这里便是执行方法的正文 return null; } } 2.然后我们可以创建一个接口Interface ##interface Subject { void action(); } 3.之后我们需要一个被代理类来实现这个接口 ##class Student implements Subject { private String name; private int cost; public Student(String name,int cost) { this.name = name; this.cost = cost; } @Override public void action() { System.out.println(name+&quot;花费了$&quot;+cost);//这里实现接口 } } 4.最后我们需要用Proxy类来创建一个代理类对象，并且通过这个代理类对象来进行代理Student stu1 = new Student(&quot;LittleGirl&quot;, 2000); myInvocationHandler myInv = new myInvocationHandler(stu1);//为Student类创建一个代理类 /** * 通过Proxy创建一个代理类的实例，此处newProxyInstance需要三个参数 * 1.第一个参数表示你要代理的这个对象的类的加载器 * 2.第二个参数表示你要代理的这个类实现的所有接口，方便其进行方法调用 * 3.第三个参数就是我们自己实现的一个实现了InvocationHandler接口的类的对象 */ Subject stuAgency = (Subject)Proxy.newProxyInstance(stu1.getClass().getClassLoader(), stu1.getClass().getInterfaces(), myInv); stuAgency.action();//这里调用aciton方法实际上是调用之前MyInvocationHandler中的invoke方法 5.运行结果如下 What is AOP?&emsp;&emsp;AOP(Aspect Oriented Programming)就是面向切面编程。其主要是利用“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，就是所谓的“方面”。&emsp;&emsp;简单来说，我个人一个比较粗陋但是比较容易理解的就是我们可以通过AOP技术来对方法进行改进，之前的OOP技术是纵向的，而我们利用横向切入的方法在不影响之前代码结构的前提下对方法进行改进扩展，例如当我们需要为方法写日志的时候，如果不使用AOP技术，那么我们需要在每一个方法前面都加上一行或者两行代码，一两个方法倒无伤大雅，如果有上千个呢？如果我们使用AOP技术，我们只需要在invoke方法中加上几行代码仅可。 System.out.println(&quot;方法开始执行。。。&quot;); method.invoke(obj, args); //这里便是执行方法的正文 System.out.println(&quot;方法执行结束。。。&quot;); &emsp;&emsp;或者我们需要对某个方法进行扩展，在执行该方法之前或者之后执行另外一个扩展方法时，我们可以这样做 if(method==targetMethod) //如果该方法为你想要改进的方法 { beforeMethod(); method.invoke(obj, args); //这里便是执行方法的正文 afterMethod(); } 最后一句话总结，AOP就是把与主业务无关的事情放到代码外面去做。","permalink":"http://yoursite.com/2019/03/25/简单理解动态代理与AOP/","categories":[],"tags":[]},{"title":"C++实现大整数乘法","date":"2019-03-06T15:52:58.000Z","path":"2019/03/06/C-实现大整数乘法/","text":"C++实现大整数乘法 大整数乘法主要用于处理位数很多的两个大数据相乘，由于计算机硬件的限制无法得到正确结果。 大整数乘法的思路主要分为以下三个步骤： 1.利用分治的思想将两个大整数逐步分解为位数较小的数，直到某个数的位数为1。 2.将分解得到的数两两进行乘法计算,结果保存在数组中（逆序存储） 3.最后将所得到的结果分别相加便可得出最终答案。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;stdlib.h&gt;using namespace std;typedef struct node&#123; int data[50]; int len=0; int c=0;&#125;*number,pnumber;/* 该函数用于截取传入的num，分解后的数的信息存储在src中。 sta为截取的开始位置，len为截取的长度*/void cp(number src,number num,int sta,int len)&#123; int j=0; for(int i=sta; i&lt;sta+len; i++) &#123; src-&gt;data[j++]=num-&gt;data[i]; &#125; src-&gt;len=len; src-&gt;c=num-&gt;c+sta; //此处存储截取到的数的幂级数（幂级数为之前数的幂级数加上截取的开始位置） return;&#125;void add(number num1,number num2,number ans) //该函数用于将两数相加&#123; number tmp; if(num1-&gt;c&lt;num2-&gt;c) //保证num1的幂级数最大 &#123; tmp=num1; num1=num2; num2=tmp; &#125; ans-&gt;c=num2-&gt;c; //结果的幂级数为两数幂级数的较小者 int alen=num1-&gt;len+num1-&gt;c; //分别获取第一个数和第二个数的总长度 int blen=num2-&gt;len+num2-&gt;c; int k=num1-&gt;c-num2-&gt;c; //获取两数幂级数之差，用于实现对阶操作 int len=alen&gt;blen? alen:blen; len-=num2-&gt;c; //结果的长度为两数总长度的最大值减去两数中幂级数的最小值 int cc=0,da,db,i; for(i=0; i&lt;len; i++) &#123; if(i&lt;k) //对阶操作，第一个数数组左侧补零 da=0; else //补零结束后，从原数组的第一个数开始取值 da=num1-&gt;data[i-k]; if(i&lt;num2-&gt;len) db=num2-&gt;data[i]; else //如果第二个数先取完，补零 db=0; if(i&gt;=num1-&gt;len+k) //如果第一个数先取完。补零 da=0; ans-&gt;data[i]=(da+db+cc)%10; cc=(da+db+cc)/10; &#125; if(cc) //最后处理剩余的进位 ans-&gt;data[i++]=cc; ans-&gt;len=i;&#125;/* 该函数用于对两个大整数进行分解直到某个数只有一位时便进行乘法计算 num1和num2分别为两个乘数，ans为结果*/void mul(number num1,number num2,number ans)&#123; int alen=num1-&gt;len/2,blen=num2-&gt;len/2; //此处用于判断两个数的位数 number tmp; if(!alen||!blen) //任何一个整数位数为1则进行乘法 &#123; if(!alen) //保证num1为长度较长的数，方便以后计算 &#123; tmp=num1; num1=num2; num2=tmp; &#125; int b=num2-&gt;data[0]; //因为num2只有一位数，所以直接获取 ans-&gt;c=num1-&gt;c+num2-&gt;c; //结果的幂级数为两数的幂级数之积 int cc=0,i; //cc表示进位 for(i=0; i&lt;num1-&gt;len; i++) &#123; ans-&gt;data[i]=(b*num1-&gt;data[i]+cc)%10; //首先保存个位数 cc=(b*num1-&gt;data[i]+cc)/10; //cc记录进位 &#125; if(cc) //如果最后还剩余进位再加上 &#123; ans-&gt;data[i++]=cc; &#125; ans-&gt;len=i; return; &#125; pnumber new1,new2,new3,new4; pnumber ans1,ans2,ans3,ans4; cp(&amp;new1,num1,0,alen); //分别对分解得到的4个数再次递归进行分解 cp(&amp;new2,num1,alen,num1-&gt;len-alen); cp(&amp;new3,num2,0,blen); cp(&amp;new4,num2,blen,num2-&gt;len-blen); mul(&amp;new1,&amp;new3,&amp;ans1); //num1分解得到的两个数与num2分解得到的两个数相乘得到4项 mul(&amp;new1,&amp;new4,&amp;ans2); mul(&amp;new2,&amp;new3,&amp;ans3); mul(&amp;new2,&amp;new4,&amp;ans4); add(&amp;ans1,&amp;ans2,ans); //将相乘得到的结果相加，保存在ans中 add(&amp;ans3,ans,&amp;ans1); add(&amp;ans4,&amp;ans1,ans);&#125;int main()&#123; char dataa[50],datab[50]; //用于接收输入的两个大整数 int al,bl,i,j,t=0; pnumber fir,sec,ans; //这里分别定义三个指针用于保存两个大整数和结果的信息 cin&gt;&gt;dataa&gt;&gt;datab; al=strlen(dataa); //获取两个大整数的长度 bl=strlen(datab); for(i=al-1; i&gt;=0; i--) //逆序存储两个大整数（两数相乘可能产生进位，逆序存储可以让进位直接加在数组末尾） fir.data[t++]=dataa[i]-'0'; t=0; for(j=bl-1; j&gt;=0; j--) sec.data[t++]=datab[j]-'0'; fir.len=al; sec.len=bl; /* 此处应该注意指针一定要慎用，本人在写这个的时候因为指针的问题浪费了很多时间 要分清楚哪个变量需要用指针。如果要使用指针一定要进行初始化，否则后果很严重。 在这里除了用于交换的临时变量和函数的实参以外都不应该用指针，因为在使用为初始化的指针时，编译器不会报错， 很难找出问题所在。同时还要分清楚函数是应该直接传地址还是指针。 */ mul(&amp;fir,&amp;sec,&amp;ans); //传入两个大整数，将结果信息保存在ans中 for(int r=ans.len-1; r&gt;=0; r--) cout&lt;&lt;ans.data[r]; return 0;&#125;","permalink":"http://yoursite.com/2019/03/06/C-实现大整数乘法/","categories":[],"tags":[]},{"title":"阿里云服务器搭建MySQL及远程访问","date":"2019-03-01T15:12:54.000Z","path":"2019/03/01/阿里云服务器搭建MySQL及远程访问-1/","text":"阿里云服务器上搭建MySQL 最近因为一个Web项目需要用到数据库，所以本着试一试的心态买了个阿里云的学生优惠服务器，然后开始了我艰难的数据库搭建，在网上找了很多资料也看了很多个教程，但是最后都没成功，最后终于在茫茫大海中找到了一篇优质博客… 这里就是你想要的东西 上面的博客实测是可以成功搭建好MySQL的，但是唯一的问题就是无法成功进行远程连接数据库，Java连接后台报错 Connection failuer。按照网上的各种方法什么更改wait_timeout和interactive_timeout之后都没用。然后也一一排除了用户权限的问题，3306端口开放的问题，服务器和客户端防火墙的问题，发现都是没问题的。 最后历经千辛万苦终于找到了问题！！！ 问题出在了阿里云的服务器上，由于是学生优惠的服务器，所以有些权限是需要自行设置的,需要我自行设置服务器的安全组规则 我们需要在内网入方向规则里面添加下面这条规则 然后在内网出方向规则也加一条 这样应该就没有问题了，可以成功连接数据库","permalink":"http://yoursite.com/2019/03/01/阿里云服务器搭建MySQL及远程访问-1/","categories":[],"tags":[]},{"title":"Java连接数据库不需要加载驱动的问题","date":"2019-02-11T10:42:49.000Z","path":"2019/02/11/Java连接数据库不需要加载驱动的问题/","text":"以前在使用jdbc对数据库进行操作的时候一般都会先加载驱动 Class.forName(“com.mysql.jdbc.Driver”); 但是后面突然会出现警告，说这个方法已经被遗弃了，然后看了看DriverManager类的源码发现有一行注释 Applications no longer need to explicitly load JDBC drivers using Class.forName(). 意思就是不需要使用这个方法加载驱动了，所以之后一直也没有用过，但是今天在搭建一个JavaWeb项目的时候连接数据库时也没有加载这个驱动，然后就一直出现问题，无法成功连接数据库，最后花了好长时间发现是这里的问题，在使用servlet访问的时候必须要加载这个驱动。还不知道是为什么","permalink":"http://yoursite.com/2019/02/11/Java连接数据库不需要加载驱动的问题/","categories":[],"tags":[]},{"title":"几种基本的排序算法","date":"2018-12-07T04:12:47.000Z","path":"2018/12/07/几种基本的排序算法/","text":"冒泡排序：12345678910111213141516171819202122232425/*冒泡排序：每次比较相邻两个元素的值然后进行交换，因为每一趟都是把当前长度序列中的最大值放到最后面，因此n个元素一共需要进行n-1趟。*/int Bubble_sort(int data[],int n)&#123; int acount=0; //计数器，累计交换的次数 for(int i=0; i&lt;n-1; i++) &#123; int index=0; //此处设一个标记，如果进行下个for循环之后index值还是0代表此时序列已经是有序的无序继续下去 for(int j=0; j&lt;n-i-1; j++) &#123; if(data[j]&gt;data[j+1]) //相邻两元素作比较 &#123; swap(data[j],data[j+1]); acount++; index=1; //只要有一次交换就index为1，表示当前序列不是有序的 &#125; &#125; if(index==0) //如果当前序列已经有序，没有进行交换就退出循环，排序完成。 return acount; &#125; return acount;&#125; 插入排序：123456789101112131415161718192021/*插入排序：每次从1开始，假设是一个抓牌的过程，首先手里有一张牌，就是0号元素然后每次从待排序数组中摸一张牌，与手中所有的牌进行比较，找到一个合适的位置就插入直到所有的元素都已经插入在手中*/int Inserting_sort(int data[],int n)&#123; int acount=0,j; for(int i=1; i&lt;n; i++) //从1开始，假设手中已经有一张牌 &#123; int temp=data[i]; //temp记录将要插入的元素的值 for(j=i; j&gt;0&amp;&amp;data[j-1]&gt;temp; j--) //从已排序的最后一个元素开始，依次与将要插入的元素比较，如果比它大，就将该元素后移 &#123; data[j]=data[j-1]; //直到找到一个适合新插入元素的位置 acount++; &#125; data[j]=temp; //此处的data[j]是小于temp的，所以把要插入元素插入在这里 &#125; return acount;&#125; 希尔排序：123456789101112131415161718192021222324/*希尔排序：对插入排序的一种改善，利用了插入排序的简单同时客服了每次只交换相邻元素减少一个逆序对的缺点每次都设置一个 增量，这样每次交换的元素就会相距一个增量的长度，就可以一次性减少多个逆序对(排序的实质其实就是减少逆序对个数可以从前面的饿冒泡和插入看出，存在几个逆序对，则需要交换几次)*/int Heal_sort(int data[],int n)&#123; int acount=0,j; for(int d=n/2; d&gt;0; d/=2) //d为增量，初始设置为n/2，之后每次除以2直到增量为1 &#123; for(int i=d; i&lt;n; i++) //这段代码其实就是把之前的插入排序的1全部用增量d代替 &#123; int temp=data[i]; //temp记录将要插入的元素 for(j=i; j&gt;=d&amp;&amp;data[j-d]&gt;temp; j-=d) //注意此处j&gt;=d，因为是从i=d开始的，在第一次的时候已经保证了d-d号元素的顺序，所以后面只要比较到j=d即可 &#123; data[j]=data[j-d]; acount++; &#125; data[j]=temp; &#125; &#125; return acount;&#125; 堆排序：12345678910111213141516171819202122232425262728293031323334/*堆排序：主要是利用最大堆和最小堆的特性进行排序，首先根据给出的数组序列构建一个最大堆（最大值在data[0]处），然后每次把最大堆的根节点与最后一个元素进行交换此时最大值就在树的最后一个叶节点处，然后把这个叶节点砍掉，因为此时把原来树的最后一个元素交换到了根节点处，所以需要重新构最大堆*/void BuildMaxheap(int data[],int t,int n) //构建最大堆的函数，t表示已t点为根节点建立最大堆(t节点的子树都是满足最大堆性质的)&#123; int ch,pa,temp=data[t]; //temp保存根节点的值 for(pa=t; pa*2+1&lt;n; pa=ch) //从根节点开始，首先在它的孩子中找一个最大值(因为下标从0开始，所以左孩子为pa*2+1) &#123; ch=2*pa+1; //先假设左孩子较大 if(data[ch]&lt;data[ch+1]&amp;&amp;ch+1&lt;n) //如果右孩子大于左孩子就CH++ ch++; if(temp&gt;=data[ch]) //如果根节点的值大于它所有孩子的值，说明它的位置是正确的，直接跳出循环 break; else //如果根节点的值小于它最大孩子的值，就把最大孩子的值赋给根节点， data[pa]=data[ch]; //然后pa=ch表示需要再在最大孩子的子树中进行比较，看之前temp的值会不会比这个孩子的最大孩子要小 &#125; data[pa]=temp; //把temp插入到正确的位置上&#125;void Heap_sort(int datas[],int n)&#123; for(int i=n/2-1; i&gt;=0; i--) //首先从最后一个有孩子的根节点开始，构建最大堆，每次减一（因为下标从0开始，所以初始i=n/2-1） BuildMaxheap(datas,i,n); for(int j=n-1; j&gt;0; j--) //最大堆构建好了之后，交换最大值和最后一个节点的值，然后把树的长度减一 &#123; swap(datas[0],datas[j]); //然后重新构建最大堆 BuildMaxheap(datas,0,j); &#125;&#125; 归并排序：123456789101112131415161718192021222324252627282930313233/*归并排序：主要是利用分而治之的思想，把整个数组不断的分割成平均两份，直到每一小份的长度为1。然后再借用一个辅助数组一步步的进行合并直到最后合并成整个数组，再把这个辅助数组赋给原数组*/void Merge_sort(int data[],int tmp[],int left,int right,int rightend)&#123; int num=rightend-left+1,leftend=right-1,demo=left; //num记录该序列中元素个数，leftend表示最短序列的末尾，demo用于辅助数组 while(left&lt;=leftend&amp;&amp;right&lt;=rightend) //当左边序列和右边序列都没有比较完的时候进行循环 &#123; if(data[left]&lt;data[right]) //如果左序列left处的值小于右序列right处的值，就把左序列left处的值加入到辅助数组中，然后left和demo都向前进一位 tmp[demo++]=data[left++]; else //这个就是右序列right处的值小于左序列left处的值的情况，类似 tmp[demo++]=data[right++]; &#125; while(left&lt;=leftend) //这里我们要处理其中一个序列还没有比较完的情况，如果是左边left还没有到达leftend处就把剩余的所有元素加入到辅助数组后面 tmp[demo++]=data[left++]; while(right&lt;=rightend) //右序列还有剩余的情况(哪边有剩余就表示剩余的元素比另一边所有的元素都大了，所有直接插入即可) tmp[demo++]=data[right++]; for(int i=0; i&lt;num; i++,rightend--) //把辅助数组复制给原数组 data[rightend]=tmp[rightend];&#125;void Merge(int data[],int tmp[],int left,int rightend)&#123; if(left&lt;rightend) //当序列中的元素大于一个是执行 &#123; int center=(left+rightend)/2; Merge(data,tmp,left,center); //归并左边 Merge(data,tmp,center+1,rightend); //归并右边 Merge_sort(data,tmp,left,center+1,rightend); //进行合并 &#125;&#125; 快速排序：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*快速排序：首先要选取一个主元，然后依据主元的值把比主元小的数放到主元左边，其余的放到主元的右边也是利用一个分而治之的递归方法。*/int midum3(int data[],int left,int right) //选取主元的函数，选取最左端，中间，最右端的中位值&#123; int center=(left+right)/2; if(data[left]&gt;data[center]) swap(data[left],data[center]); if(data[left]&gt;data[right]) swap(data[left],data[right]); if(data[center]&gt;data[right]) swap(data[center],data[right]); //三个if之后到这里最左端&lt;=中间&lt;=最右端 swap(data[center],data[right-1]); //把中位值隐藏都最右端处 return data[right-1]; //返回主元&#125;void quicksort(int data[],int left,int right)&#123; if(left&lt;=right) //当前序列元素个数不为0时执行 &#123; int cutoff=10; //这是一个阈值，当前序列元素个数小于该值时可以使用简单的插入排序，这样可以节省时间。因为元素较少时插入可能会比递归快 if(right-left&lt;cutoff) Inserting_sort(data+left,right-left+1); //小于阈值就调用插入排序，从data+left开始至后面的right-left+1个元素 else &#123; int pivot=midum3(data,left,right); //选取主元 int i=left,j=right-1; //i为左边的哨兵，j为右边的哨兵 while(i&lt;j) //当i=j时就退出循环 &#123; while(data[++i]&lt;=pivot&amp;&amp;i&lt;j); //注意此处的顺序很重要，根据你主元的位置来决定方向，如果主元是0，就从右边开始，如果主元在右边就先从左边开始 while(data[--j]&gt;=pivot&amp;&amp;i&lt;j); //右边循环直到一个比主元小的值，左边循环直到一个比主元大的值 if(i&lt;j) //i&lt;j就交换两元素，一直直到i==j swap(data[i],data[j]); &#125; swap(data[i],data[right-1]); //交换i处元素与主元，给主元重新定位 quicksort(data,left,i-1); //递归对主元的左边进行排序 quicksort(data,i+1,right); //递归对主元的右边进行排序（此时不再包括主元进去） &#125; &#125;&#125;void quick_sort(int data[],int n)&#123; quicksort(data,0,n-1);&#125;","permalink":"http://yoursite.com/2018/12/07/几种基本的排序算法/","categories":[],"tags":[]},{"title":"最小生成树Prim算法","date":"2018-11-24T08:51:59.000Z","path":"2018/11/24/最小生成树Prim算法/","text":"最小生成树Prim算法实现，输出最小生成树总路径长： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;int mapcost[1024][1024]; //存储输入的地图信息，每条边的权值using namespace std;int lowcost[1024],book[1024]; //lowcost为辅助数组，动态记录从源点到个点的最短距离，book数组用来标记一个点是否在已生成树中int prim(int n) //prim算法，参数为点的个数&#123; int sum=0; for(int i=1; i&lt;=n; i++) //lowcost数组初始化，每个点的lowcost值为用户输入信息中从源点（源点为1）到个点的距离 &#123; lowcost[i]=mapcost[1][i]; &#125; book[1]=1; //从1开始，把1收入到生成树中 int mins,index,t; //mins用来记录最小值，index记录lowcost最小值的点 for(int i=1; i&lt;n; i++) &#123; mins=999; for(t=1; t&lt;=n; t++) //寻找已生成树中能够到达的权值最小的边的点 &#123; if(book[t]==0&amp;&amp;mins&gt;lowcost[t]) &#123; mins=lowcost[t]; index=t; &#125; &#125; sum+=lowcost[index]; //记录路径长度 book[index]=1; //将index点加入到生成树中 for(int g=1; g&lt;=n; g++) //因为生成树中多了一个节点index，所有需要重新调整lowcost数组，lowcost数组始终记录从已生成树中到其余个点的最短距离 &#123; if(book[g]==0&amp;&amp;mapcost[index][g]&lt;lowcost[g]) &#123; lowcost[g]=mapcost[index][g]; &#125; &#125; &#125; for(int j=1;j&lt;=n;j++) //处理未连通的情况 &#123; if(book[j]==0) return -1; &#125; return sum;&#125;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; if(m&lt;n-1) //不能连通图的情况 cout&lt;&lt;-1; else &#123; int x,y,z; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) //初始化mapcost数组 mapcost[i][j]=999; &#125; for(int i=0; i&lt;m; i++) //因为是无向图，所以需要xy，yx赋两次值 &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; mapcost[x][y]=z; mapcost[y][x]=z; &#125; int re=prim(n); cout&lt;&lt;re; &#125; return 0;&#125;","permalink":"http://yoursite.com/2018/11/24/最小生成树Prim算法/","categories":[],"tags":[]},{"title":"简述网桥、交换机、路由器、网关在网络中的作用","date":"2018-11-24T08:32:20.000Z","path":"2018/11/24/简述网桥、交换机、路由器、网关在网络中的作用/","text":"1.网桥 网桥是一个局域网与另一个局域网之间建立连接的桥梁，网桥属于数据链路层设备，它的作用是扩展网络和通信手段，在各种传输介质中转发数据信号，扩展网络的距离，同时又有选择的将现有地址的信号从一个传输介质发送到另一个传输介质，并且能够有效的限制两个介质系统中无关紧要的通信，简单来说就是将两个局域网连接起来然后根据MAC地址来转发数据帧。 2.交换机 交换机也是工作在数据链路层，它比集线器智能，它能够分辨出数据帧中的源MAC地址和目的MAC地址，因此可以在任意两个端口间建立联系，在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧能够直接由源地址到达目的地址，交换机通过对信息进行重新生成，并且经过内部处理后转发至指定端口，具备自动寻址能力和交换作用，但是交换机不能读懂IP地址，它只知道MAC地址。交换机可以理解为高级的网桥，它是改进版的网桥，性能更好，交换机连接的是独立的计算机，而网桥连接的是LAN （交换机是使用硬件来完成以往网桥使用软件来完成过滤、学习和转发过程的任务，交换机的速度要比集线器快，因为它可以分辨出源MAC地址和目的MAC地址，可以在指定的任意两个端口之间建立联系，而不用像集线器一样把数据发送到所有端口，这样过滤降低了整个网络中的数据传输量，提高了效率，交换机还可以把网络拆解成网络分支，分割网络数据流，这样可以减少每个网络分支的数据信息流量而使得每个网络更加有效） 3.路由器 路由器工作在第三层网络层，它又比之前的交换机要聪明，因为它可以读懂数据中的IP地址，每当它接收到一个数据包，就会检查其中的IP地址，如果是本地的IP地址就不会理会，如果是其他网络的IP地址就会把数据包转发出本地网络。并且路由器使用专门的软件协议从逻辑上对整个网络进行划分。（一台支持IP协议的路由器可以把网络划分成多个子网络，只要指向特殊IP地址的网络流量才可以通过路由器，当IP子网中的一台主机发送IP分组给同一IP子网中的另一台主机时，它将直接把IP分组发送到网络上，对方就可以收到，但是如果是发送给一个不同子网络的主机时，他就要选择一个能够达到目的子网络的路由器，把IP分组发给它，然后再由该路由器把IP分组发送到目的地） 对于每一个接收到的数据包，路由器都会重新计算校验值，并且写入新的物理地址。网络中的设备用它们的网络地址互相通信。IP地址是与硬件无关的“逻辑”地址。Internet就是成千上万个IP子网通过路由器连接起来的国际性网络。路由器的主要工作就是为经过路由器的每个IP数据包寻找一条最佳传输路径，并将该数据有效的传送到目的站点，把数据传输到正确的网络。 4.网关 网关又称网间连接器，协议转换器。网关在网络层上实现网络互联，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连，网络既可以用于广域网互联也可以用于局域网互连。网关是一种充当转换重任的计算机系统或设备，使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器，它会对收到的信息都进行重新打包，以适应系统的需求。简单来说就是连接两个不同网络的接口。 1.交换机和路由器的区别？ 从应用上说： 交换机和路由器的使用中最大的区别莫过于路由器内部可实现拨号上网，然后通过共享给多台电脑同时上网，而交换机内部不具有拨号功能，但交换机的作用是将网络信号分流，以实现更多电脑连接共享上网。 大家可以这样认为，交换机可以将多台电脑连接起来，与交换机互连的电脑本身则具备了互相通信的功能，组建成了一个内部局域网，但需要访问互联网还需要有网络支持，因此交换机一端需要连接到路由器，路由器即可实现交换功能，还可以拨号，实现宽带连接，并将宽带资源分配个交换机使用，这样就实现了多台电脑共享上网。 从概念上说： 路由，是三层设备，有选择道路的作用。比如你去罗马，有很多路可以走，怎么走省钱省时间，就是路由要做的，解决你应该按照那条路走的问题。当然还有基于三层的其他功能。 交换机，是二层设备。他就像你家门前的如或者你们楼道，附近的住户都知道去几层几号怎么走。 举个例子说明路由器和交换机的配合：我要去找小明借电脑，小明说他不在家，叫我自己去拿吧，同时还告诉我他家的地址是XX路XX小区XX号（好比ip地址），我根据小明告诉我的地址找到了小明的家（路由器的功能，寻找路径）。我进门发现他家居然有10台电脑，哪台是借给我的那台呢？噢，原来小明还告诉我他要借给我的电脑的编号（MAC地址），那样我就可以根据编号找到相应的电脑了。 在上述的例子中，如果我没有路由器，我就不知道怎么去小明家，更不用说拿到电脑；如果我没有拿到所需的电脑编号，我也拿不到电脑，因为有十台电脑，我不能乱拿；有个特殊情况，如果小明家只有一台电脑呢？那我就不需要编号就可以确定拿哪台电脑，也就是不需要交换机。 为什么有时候还要在路由器的后面先接1台交换机再接计算机？ 路由器是可以直接接电脑等终端设备，为什么标准都是路由器接交换机然后再接电脑等终端，是因为路由器本来就是一个路由设备，用来选路的，不适合大量的数据交换，交换机是用来大量数据交换的，终端在内网的性质就是需要使用交换机，所以标准就是路由器地下接交换机的形式。一般是情况就是在路由器下面接交换机，路由器主要起数据转发，也就是寻址、路由的功能，交换机起到用户接入的目的。但是家用的路由器的话直接就接计算机就可以了，而不必考虑再接交换机。 原文：https://blog.csdn.net/qq_25606103/article/","permalink":"http://yoursite.com/2018/11/24/简述网桥、交换机、路由器、网关在网络中的作用/","categories":[],"tags":[]},{"title":"操作系统中的几种进程调度策略","date":"2018-11-23T13:42:57.000Z","path":"2018/11/23/操作系统中的几种进程调度策略/","text":"1.先来先服务调度算法：该算法即可以用与作业调度又可以用与进程调度，作业调度使用该算法便每次调度都从作业队列中选择一个或者多个处于队列最前面的作业，把他调入内存，为它分配资源，创建线程然后放入就绪队列，进程调度使用该算法便每次从就绪队列中选择一个最先进入队列的进程，让它开始运行 2.短作业短进程优先调度：作业调度使用该算法便从后备队列从选择一个或者多个预计运行时间最短的作业加入到内存中运行，进程调度使用该算法就是从就绪队列中选一个预计运行时间最短的让其开始运行 3.非抢占式优先权算法：优先权算法就是为每一个作业或者进程分配一个优先级，每次都优先开始优先级较高的作业或者线程。非抢占式优先权算法就是当系统把处理机分配给一个优先级最高的进程之后，该进程便会一直执行下去直到进程运行完或者某事件使该进程放弃处理机时，不会因为就绪队列中加入了一个优先级更高的进程而放弃执行该进程 4.抢占式优先权算法：就跟第3个差不多，只不过当原最高优先级进程运行时，如果就绪队列中加入了一个优先级更高的进程，系统就会停止原进程，让新的优先级最高的进程投入执行 5.高相应比优先调度算法：此算法与之前的优先权和短作业算法基本相似，只不过优先权的计算方法为（等待时间+要求服务时间）/要求服务时间，即每个进程的优先权会随等待被执行时间而改变，这样避免了一个作业或者进程因为预计执行时间太长而一直不被执行，每个作业的优先级随着等待时间增长而升高 6.多级反馈队列调度算法：该算法基于时间片轮转法，简单来说就是为每一个进程都分配一个时间片段，当执行一个进程的时间片用完了之后便把该进程放到就绪队列的最末尾，然后继续把时间片分配给下一个线程，使得每一个线程都可以被执行多级反馈就是设置了多个就绪队列，算是对前面几种算法的一个结合改进吧，并且每个就绪队列的优先级都不同，优先级高的所分配的时间片就长，反之则较低。假设第一队列中的一个进程在时间片内执行完了便会撤离系统，如果没有执行完便会被加入到第二队列的末尾，等待下一次执行，如果第二队列中分配的时间片内还是没有完成就加入到第三队列末尾，以此类推。","permalink":"http://yoursite.com/2018/11/23/操作系统中的几种进程调度策略/","categories":[],"tags":[]},{"title":"当一个线程进入一个synchronized方法之后，其他线程能否进入此对象的其他方法","date":"2018-11-23T13:38:51.000Z","path":"2018/11/23/当一个线程进入一个synchronized方法之后，其他线程能否进入此对象的其他方法/","text":"分为几种情况：1.其他方法前如果没有加synchronized关键字，就可以进入，因为其他的方法并没有被同步锁上锁，可以被正常访问 2.如果这个synchronized方法内部调用了wait，则可以进入其他synchronized方法，因为在方法中运行到wait时，该线程便退出了运行状态，对象的同步锁就被解开了 3.如果其他方法都加了synchronized方法并且该方法内部没有调用wait，则不能进入其他方法，同步锁的标志是一个对象，线程进入一个synchronized方法时，同步锁便被上锁了，包括该对象的所有其他synchronized方法 4.如果其他方法是static的，它用的同步锁是当前类的字节码，与非静态方法不能同步，所以可以进入其他静态方法。非静态方法可以使用this来进行同步，但是调用静态方法时，对象实例不一定被创建，所以不能使用this进行同步，而是使用一个class对象进行同步。所以两者同步锁的对象是不同的","permalink":"http://yoursite.com/2018/11/23/当一个线程进入一个synchronized方法之后，其他线程能否进入此对象的其他方法/","categories":[],"tags":[]},{"title":"计算机按下开机键后的简单启动过程","date":"2018-11-20T15:08:42.000Z","path":"2018/11/20/计算机按下开机键后的简单启动过程/","text":"第一阶段：BIOS BIOS（Basic Input/Output System）是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输入出的程序、开机后自检程序和系统自启动程序，它可以从CMOS中读写系统设置的具体信息，主要功能是为计算机提供最底层、最直接的硬件设置和控制。 BIOS程序首先检查计算机能否满足运行的基本条件即硬件自检POST（Power on self test），检测系统中的一些关键设备是否存在和能否正常工作，如内存和显卡等等，如果发现了一些致命的错误，就会喇叭发声来报告错误。然后BIOS把控制权交给下一阶段的启动程序，BIOS需要知道下一阶段的启动程序具体放在哪一个设备中，所以它需要一个外部设备的排序，优先转交控制权给排在前面的设备，这种排序叫做“启动顺序”。 第二阶段：主引导记录 BIOS按照启动顺序，把控制权交给排在第一位的储存设备，这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节，这最前面的512个字节就叫做“主引导记录”。 第三阶段：硬盘启动 这是计算机的控制权就要转交给硬盘的某个分区了。 第四阶段：操作系统分区中会记载操作系统的信息，然后控制权交给操作系统，操作系统的内核首先被载入内存，进而启动相关进程，计算机启动过程便完成了。","permalink":"http://yoursite.com/2018/11/20/计算机按下开机键后的简单启动过程/","categories":[],"tags":[]},{"title":"CPU存储器，指令执行过程，中断处理(简述)","date":"2018-11-20T15:02:32.000Z","path":"2018/11/20/CPU存储器，指令执行过程，中断处理-简述/","text":"CPU主要有：1.数据寄存器：数据寄存器主要用来保存操作数和运算结果等信息，从而节省了读取操作数所需占用总线和访问存储器的时间。2.变址寄存器：主要用于存放存储单元在段内的偏移量，用他们可以实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。3.指针存储器：主要用于访问堆栈内的存储单元，并且规定BP为基指针寄存器，用它可以直接存取堆栈中的数据，SP为堆栈指针寄存器，它只可以访问栈顶。（变址寄存器和指针寄存器作为通用寄存器也可以存储操作数和运算结果）4.段寄存器：段寄存器是根据内存分段的管理模式而设置的，内存单元的物理地址是有段寄存器的值和一个偏移量组合而成的，这样就可以用两个较少位数的值组合成一个可以访问较大物理空间的内存地址。5.指令寄存器：指令指针EIP和IP是存放下次将要执行的指令在代码段的偏移量，用来提供指令在存储器中的地址 一条指令的执行通常有五个步骤：取指令-&gt;指令译码-&gt;执行指令-&gt;访存取数-&gt;结果写回1.取指令：将一条指令从主存中读取到指令寄存器2.指令译码：由指令译码器按照预定的指令格式，对取回的指令进行解释和拆分，识别区分出不同的指令类别以及获取各种操作数的方法3.执行指令：完成指令所规定的各种操作4.访存取数：有时候一条指令可能会访问主存读取操作数，根据指令地址码从主存中取出数据。4.结果写回：一般把指令阶段运行后的结果存储到数据存储器中，方便以后的读取。 中断处理：当CPU执行一条指令的时候，如果此时有一个外设发出了中断请求，那么CPU就会在满足相应的情况下，发出中断相应信号并且关闭中断，表示不再接受另一个设备的中断，然后寻找发出中断信号的设备，并且保存CPU自己的程序计数器内容，转移到处理该中断源的中断服务程序。CPU再保存现场信息，设备服务以后将会回复现场信息。这些都完成了之后，就会继续开放中断并且返回到原来被中的的主程序的下一条命令。过程： 请求中断-&gt;中断相应-&gt;关闭中断-&gt;保护断点-&gt;中断源识别-&gt;保护现场-&gt;恢复现场-&gt;中断返回（保护现场：因为主程序和中断服务子程序都要使用CPU内部寄存器等资源，为了不让中断处理程序破坏主程序中寄存器的内容，要先把个寄存器的内容压入堆栈保护起来，再进入中断处理。）","permalink":"http://yoursite.com/2018/11/20/CPU存储器，指令执行过程，中断处理-简述/","categories":[],"tags":[]},{"title":"浅谈MVC架构","date":"2018-11-17T16:15:16.000Z","path":"2018/11/18/浅谈MVC架构/","text":"MVC代表着“model”、“view”、“controller”。使用MVC开发的web应用程序，对搜索引擎更加友好。Model：model基本上是一个C#和VB.net的类model可以被view和controller访问controller通过model向view传输数据view使用model在页面上显示数据View：view层主要是一些ASPX页面文件，不包括后台代码view中可以对所有的页面进行HTML生成和格式化view中可以只用内联代码进行一些动态渲染view中的ASPX请求，只能调用controller中的方法Controller：controller是MVC架构的核心controller基本上是一些主要继承了system.mvc.controller的C#或者VB.NET的类controller中的所有方法都是用来响应浏览器或者view的请求的controller通过model层来向view层的页面传输数据controller使用viewdata向view层传输数据1.浏览器请求用户在浏览器中输入一个网址：http://xxx.com/home/index/,就产生了一个浏览器请求2.Global.asax的作用，MVC路由这个网址首先被Global.asax文件中的application_start（）方法捕获并解释出控制器，方法和ID，此时控制器为home方法为index（）ID为空3.controller层与调用方法现在MVC在controller目录下查找home控制器的方法，不同的控制器中包含不同的方法。此时找到index（）方法，调用这个方法之后，返回一个纯字符串或者被view层展示的HTML代码4.调用view层调用view层会访问view目录下指定的ASPX页面，并且生成一个相应的HTML代码返回给浏览器","permalink":"http://yoursite.com/2018/11/18/浅谈MVC架构/","categories":[],"tags":[]},{"title":"多项式相加链表和线性表实现","date":"2018-11-16T04:50:04.000Z","path":"2018/11/16/多项式相加链表和线性表实现/","text":"线性表实现:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;const int MAX = 10000;int main()&#123; int arr[MAX]; for (int i = 0; i &lt; MAX; ++i) arr[i] = 0; int t=2, n, m; int co, exp, max = 0; cout&lt;&lt;\"请输入第一个多项式的项数:\"; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; cout&lt;&lt;\"请依次输入系数和指数：\"; cin &gt;&gt; co &gt;&gt; exp; if (exp &gt; max) max = exp; arr[exp] = co; &#125; cout&lt;&lt;\"\\n请输入第二个多项式的项数:\"; cin &gt;&gt; m; for (int i = 0; i &lt; m; ++i) &#123; cout&lt;&lt;\"请依次输入系数和指数：\"; cin &gt;&gt; co &gt;&gt; exp; if (exp &gt; max) max = exp; arr[exp] += co; &#125; cout&lt;&lt;\"\\n\"; for (int i = max; i &gt;= 0; --i) if (arr[i] != 0) &#123; cout &lt;&lt; arr[i] &lt;&lt;\"*x^\"&lt;&lt; i ; if(i!=0) cout&lt;&lt;\"+\"; &#125; return 0;&#125; 链表实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include &lt;limits.h&gt;#include &lt;math.h&gt;#include &lt;process.h&gt;using namespace std;typedef struct LNode&#123; int coef; int expn; struct LNode *next;&#125; LNode,*polynomail;void creatpolyn(polynomail &amp;p,int m)&#123; int i; int coef; int expn; polynomail s; p=(polynomail)malloc(sizeof(LNode)); p-&gt;next=NULL; for(i=1; i&lt;=m; ++i) &#123; s=(polynomail)malloc(sizeof(LNode)); cout&lt;&lt;\"请输入一元多项式的系数和指数:\"; cin&gt;&gt;coef&gt;&gt;expn; s-&gt;coef=coef; s-&gt;expn=expn; s-&gt;next=p-&gt;next; p-&gt;next=s; &#125;&#125;polynomail addpolyn(polynomail &amp;pa,polynomail &amp;pb)&#123; polynomail c,pc; pc=(polynomail)malloc(sizeof(LNode)); pc-&gt;next=NULL; pa=pa-&gt;next; pb=pb-&gt;next; while(pa &amp;&amp; pb) &#123; if((pa-&gt;expn)==(pb-&gt;expn)) &#123; c=(polynomail)malloc(sizeof(LNode)); c-&gt;expn=pa-&gt;expn; c-&gt;coef=((pa-&gt;coef)+(pb-&gt;coef)); pa=pa-&gt;next; pb=pb-&gt;next; &#125; else if((pa-&gt;expn)&gt;(pb-&gt;expn)) &#123; c=(polynomail)malloc(sizeof(LNode)); c-&gt;expn=pb-&gt;expn; c-&gt;coef=pb-&gt;coef; pb=pb-&gt;next; &#125; else &#123; c=(polynomail)malloc(sizeof(LNode)); c-&gt;expn=pa-&gt;expn; c-&gt;coef=pa-&gt;coef; pa=pa-&gt;next; &#125; c-&gt;next=pc-&gt;next; pc-&gt;next=c; &#125; if(!pa &amp;&amp; pb) &#123; while(c-&gt;next!=NULL) &#123; c=c-&gt;next; &#125; c-&gt;next=pb; &#125; if(!pb &amp;&amp; pa) &#123; while(c-&gt;next!=NULL) &#123; c=c-&gt;next; &#125; c-&gt;next=pa; &#125; return pc;&#125;void printpolyn(polynomail &amp;p)&#123; while(p-&gt;next!=NULL) &#123; p=p-&gt;next; cout&lt;&lt;p-&gt;coef&lt;&lt;\"*X^\"&lt;&lt;p-&gt;expn; if(p-&gt;next!=NULL) cout&lt;&lt;\"+\"; &#125;&#125;int main()&#123; int n,m; polynomail pa,pb,pc; cout&lt;&lt;\"请输入一元多项式S1的项数:\"; scanf(\"%d\",&amp;n); creatpolyn(pa,n); cout&lt;&lt;\"请输入一元多项式S2的项数:\"; scanf(\"%d\",&amp;m); creatpolyn(pb,m); pc=addpolyn(pa,pb); cout&lt;&lt;\"\\n结果是:S1+S2= \"; printpolyn(pc);&#125;","permalink":"http://yoursite.com/2018/11/16/多项式相加链表和线性表实现/","categories":[],"tags":[]},{"title":"从浏览器输入url到显示网页发生了什么（简要过程）","date":"2018-11-15T13:39:42.000Z","path":"2018/11/15/从浏览器输入url到显示网页发生了什么（简要过程）/","text":"1.输入url2.应用层dns对域名进行解析，现在本地找有没有相应的IP地址，如果有就返回，没有就请求上级dns3.应用层客户端发送http请求4.传输层传输报文5.网络层IP协议查询MAC地址6.数据发送到数据链路层，服务器接收数据7.服务器响应请求返回相应文件8.页面渲染","permalink":"http://yoursite.com/2018/11/15/从浏览器输入url到显示网页发生了什么（简要过程）/","categories":[],"tags":[]},{"title":"内存中堆、栈和静态存储区的用法","date":"2018-11-15T07:42:14.000Z","path":"2018/11/15/that/","text":"1.堆堆中存储的全部是对象，每个对象都包含一个与之对应的class，不存储基本类型和对象的引用。在java JVM中只有一个堆区，且该堆区被所有线程共享。堆一般由程序员进行分配和释放。2.栈栈中存储的是基础数据类型和自定义对象的引用，内存中由多个栈区，每个线程都拥有属于他自己的一个栈区，并且栈区中的所有成员都是私有的，不能被其他线程的其他栈所访问。栈分为三个部分：基本类型变量区，执行环境上下文，操作指令区。栈是由系统编译器自行分配的。3.静态存储区存储所有的class和static变量，包含的都是程序中永远唯一的元素，他跟堆一样也是被所有线程所共享的。全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域中，未初始化的全局变量和静态变量在相邻的一块区域最有效率算2*8应该是移位运算吧，2左移三位？2&lt;&lt;3，这样应该不会占内存","permalink":"http://yoursite.com/2018/11/15/that/","categories":[],"tags":[]},{"title":"java关键字static、final、this、super总结","date":"2018-11-15T07:41:05.000Z","path":"2018/11/15/java关键字static、final、this、super总结/","text":"用static声明一个变量或方法，表示它是静态的，在之后可以对变量进行改变或者对静态方法进行重写，但是final表示最终的，由final声明的变量不能被重新赋值，方法不能被重写重构，final类不能被其他类所继承。 this和super一般在构造方法中比较常用(this一般用在该类的方法或者构造函数当中，而super一般用在一个继承了其他类的子类的方法或者构造方法中)，this可以调用该类的成员变量或者成员方法，并且可以在方法的任何位置使用，而super则是能对该类的父类的成员变量或方法进行调用，并且要调用super关键字必须在每个方法中的第一行进行调用","permalink":"http://yoursite.com/2018/11/15/java关键字static、final、this、super总结/","categories":[],"tags":[]}]}