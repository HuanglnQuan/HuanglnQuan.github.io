{"meta":{"title":"HuanglnQuan.blog","subtitle":null,"description":null,"author":"Mac Huang","url":"http://yoursite.com"},"posts":[{"title":"操作系统中的几种进程调度策略","date":"2018-11-23T13:42:57.000Z","path":"2018/11/23/操作系统中的几种进程调度策略/","text":"1.先来先服务调度算法：该算法即可以用与作业调度又可以用与进程调度，作业调度使用该算法便每次调度都从作业队列中选择一个或者多个处于队列最前面的作业，把他调入内存，为它分配资源，创建线程然后放入就绪队列，进程调度使用该算法便每次从就绪队列中选择一个最先进入队列的进程，让它开始运行 2.短作业短进程优先调度：作业调度使用该算法便从后备队列从选择一个或者多个预计运行时间最短的作业加入到内存中运行，进程调度使用该算法就是从就绪队列中选一个预计运行时间最短的让其开始运行 3.非抢占式优先权算法：优先权算法就是为每一个作业或者进程分配一个优先级，每次都优先开始优先级较高的作业或者线程。非抢占式优先权算法就是当系统把处理机分配给一个优先级最高的进程之后，该进程便会一直执行下去直到进程运行完或者某事件使该进程放弃处理机时，不会因为就绪队列中加入了一个优先级更高的进程而放弃执行该进程 4.抢占式优先权算法：就跟第3个差不多，只不过当原最高优先级进程运行时，如果就绪队列中加入了一个优先级更高的进程，系统就会停止原进程，让新的优先级最高的进程投入执行 5.高相应比优先调度算法：此算法与之前的优先权和短作业算法基本相似，只不过优先权的计算方法为（等待时间+要求服务时间）/要求服务时间，即每个进程的优先权会随等待被执行时间而改变，这样避免了一个作业或者进程因为预计执行时间太长而一直不被执行，每个作业的优先级随着等待时间增长而升高 6.多级反馈队列调度算法：该算法基于时间片轮转法，简单来说就是为每一个进程都分配一个时间片段，当执行一个进程的时间片用完了之后便把该进程放到就绪队列的最末尾，然后继续把时间片分配给下一个线程，使得每一个线程都可以被执行多级反馈就是设置了多个就绪队列，算是对前面几种算法的一个结合改进吧，并且每个就绪队列的优先级都不同，优先级高的所分配的时间片就长，反之则较低。假设第一队列中的一个进程在时间片内执行完了便会撤离系统，如果没有执行完便会被加入到第二队列的末尾，等待下一次执行，如果第二队列中分配的时间片内还是没有完成就加入到第三队列末尾，以此类推。","permalink":"http://yoursite.com/2018/11/23/操作系统中的几种进程调度策略/","categories":[],"tags":[]},{"title":"当一个线程进入一个synchronized方法之后，其他线程能否进入此对象的其他方法","date":"2018-11-23T13:38:51.000Z","path":"2018/11/23/当一个线程进入一个synchronized方法之后，其他线程能否进入此对象的其他方法/","text":"分为几种情况：1.其他方法前如果没有加synchronized关键字，就可以进入，因为其他的方法并没有被同步锁上锁，可以被正常访问 2.如果这个synchronized方法内部调用了wait，则可以进入其他synchronized方法，因为在方法中运行到wait时，该线程便退出了运行状态，对象的同步锁就被解开了 3.如果其他方法都加了synchronized方法并且该方法内部没有调用wait，则不能进入其他方法，同步锁的标志是一个对象，线程进入一个synchronized方法时，同步锁便被上锁了，包括该对象的所有其他synchronized方法 4.如果其他方法是static的，它用的同步锁是当前类的字节码，与非静态方法不能同步，所以可以进入其他静态方法。非静态方法可以使用this来进行同步，但是调用静态方法时，对象实例不一定被创建，所以不能使用this进行同步，而是使用一个class对象进行同步。所以两者同步锁的对象是不同的","permalink":"http://yoursite.com/2018/11/23/当一个线程进入一个synchronized方法之后，其他线程能否进入此对象的其他方法/","categories":[],"tags":[]},{"title":"计算机按下开机键后的简单启动过程","date":"2018-11-20T15:08:42.000Z","path":"2018/11/20/计算机按下开机键后的简单启动过程/","text":"第一阶段：BIOS BIOS（Basic Input/Output System）是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输入出的程序、开机后自检程序和系统自启动程序，它可以从CMOS中读写系统设置的具体信息，主要功能是为计算机提供最底层、最直接的硬件设置和控制。 BIOS程序首先检查计算机能否满足运行的基本条件即硬件自检POST（Power on self test），检测系统中的一些关键设备是否存在和能否正常工作，如内存和显卡等等，如果发现了一些致命的错误，就会喇叭发声来报告错误。然后BIOS把控制权交给下一阶段的启动程序，BIOS需要知道下一阶段的启动程序具体放在哪一个设备中，所以它需要一个外部设备的排序，优先转交控制权给排在前面的设备，这种排序叫做“启动顺序”。 第二阶段：主引导记录 BIOS按照启动顺序，把控制权交给排在第一位的储存设备，这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节，这最前面的512个字节就叫做“主引导记录”。 第三阶段：硬盘启动 这是计算机的控制权就要转交给硬盘的某个分区了。 第四阶段：操作系统分区中会记载操作系统的信息，然后控制权交给操作系统，操作系统的内核首先被载入内存，进而启动相关进程，计算机启动过程便完成了。","permalink":"http://yoursite.com/2018/11/20/计算机按下开机键后的简单启动过程/","categories":[],"tags":[]},{"title":"CPU存储器，指令执行过程，中断处理(简述)","date":"2018-11-20T15:02:32.000Z","path":"2018/11/20/CPU存储器，指令执行过程，中断处理-简述/","text":"CPU主要有：1.数据寄存器：数据寄存器主要用来保存操作数和运算结果等信息，从而节省了读取操作数所需占用总线和访问存储器的时间。2.变址寄存器：主要用于存放存储单元在段内的偏移量，用他们可以实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。3.指针存储器：主要用于访问堆栈内的存储单元，并且规定BP为基指针寄存器，用它可以直接存取堆栈中的数据，SP为堆栈指针寄存器，它只可以访问栈顶。（变址寄存器和指针寄存器作为通用寄存器也可以存储操作数和运算结果）4.段寄存器：段寄存器是根据内存分段的管理模式而设置的，内存单元的物理地址是有段寄存器的值和一个偏移量组合而成的，这样就可以用两个较少位数的值组合成一个可以访问较大物理空间的内存地址。5.指令寄存器：指令指针EIP和IP是存放下次将要执行的指令在代码段的偏移量，用来提供指令在存储器中的地址 一条指令的执行通常有五个步骤：取指令-&gt;指令译码-&gt;执行指令-&gt;访存取数-&gt;结果写回1.取指令：将一条指令从主存中读取到指令寄存器2.指令译码：由指令译码器按照预定的指令格式，对取回的指令进行解释和拆分，识别区分出不同的指令类别以及获取各种操作数的方法3.执行指令：完成指令所规定的各种操作4.访存取数：有时候一条指令可能会访问主存读取操作数，根据指令地址码从主存中取出数据。4.结果写回：一般把指令阶段运行后的结果存储到数据存储器中，方便以后的读取。 中断处理：当CPU执行一条指令的时候，如果此时有一个外设发出了中断请求，那么CPU就会在满足相应的情况下，发出中断相应信号并且关闭中断，表示不再接受另一个设备的中断，然后寻找发出中断信号的设备，并且保存CPU自己的程序计数器内容，转移到处理该中断源的中断服务程序。CPU再保存现场信息，设备服务以后将会回复现场信息。这些都完成了之后，就会继续开放中断并且返回到原来被中的的主程序的下一条命令。过程： 请求中断-&gt;中断相应-&gt;关闭中断-&gt;保护断点-&gt;中断源识别-&gt;保护现场-&gt;恢复现场-&gt;中断返回（保护现场：因为主程序和中断服务子程序都要使用CPU内部寄存器等资源，为了不让中断处理程序破坏主程序中寄存器的内容，要先把个寄存器的内容压入堆栈保护起来，再进入中断处理。）","permalink":"http://yoursite.com/2018/11/20/CPU存储器，指令执行过程，中断处理-简述/","categories":[],"tags":[]},{"title":"浅谈MVC架构","date":"2018-11-17T16:15:16.000Z","path":"2018/11/18/浅谈MVC架构/","text":"MVC代表着“model”、“view”、“controller”。使用MVC开发的web应用程序，对搜索引擎更加友好。Model：model基本上是一个C#和VB.net的类model可以被view和controller访问controller通过model向view传输数据view使用model在页面上显示数据View：view层主要是一些ASPX页面文件，不包括后台代码view中可以对所有的页面进行HTML生成和格式化view中可以只用内联代码进行一些动态渲染view中的ASPX请求，只能调用controller中的方法Controller：controller是MVC架构的核心controller基本上是一些主要继承了system.mvc.controller的C#或者VB.NET的类controller中的所有方法都是用来响应浏览器或者view的请求的controller通过model层来向view层的页面传输数据controller使用viewdata向view层传输数据1.浏览器请求用户在浏览器中输入一个网址：http://xxx.com/home/index/,就产生了一个浏览器请求2.Global.asax的作用，MVC路由这个网址首先被Global.asax文件中的application_start（）方法捕获并解释出控制器，方法和ID，此时控制器为home方法为index（）ID为空3.controller层与调用方法现在MVC在controller目录下查找home控制器的方法，不同的控制器中包含不同的方法。此时找到index（）方法，调用这个方法之后，返回一个纯字符串或者被view层展示的HTML代码4.调用view层调用view层会访问view目录下指定的ASPX页面，并且生成一个相应的HTML代码返回给浏览器","permalink":"http://yoursite.com/2018/11/18/浅谈MVC架构/","categories":[],"tags":[]},{"title":"多项式相加链表和线性表实现","date":"2018-11-16T04:50:04.000Z","path":"2018/11/16/多项式相加链表和线性表实现/","text":"线性表实现:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;const int MAX = 10000;int main()&#123; int arr[MAX]; for (int i = 0; i &lt; MAX; ++i) arr[i] = 0; int t=2, n, m; int co, exp, max = 0; cout&lt;&lt;\"请输入第一个多项式的项数:\"; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; cout&lt;&lt;\"请依次输入系数和指数：\"; cin &gt;&gt; co &gt;&gt; exp; if (exp &gt; max) max = exp; arr[exp] = co; &#125; cout&lt;&lt;\"\\n请输入第二个多项式的项数:\"; cin &gt;&gt; m; for (int i = 0; i &lt; m; ++i) &#123; cout&lt;&lt;\"请依次输入系数和指数：\"; cin &gt;&gt; co &gt;&gt; exp; if (exp &gt; max) max = exp; arr[exp] += co; &#125; cout&lt;&lt;\"\\n\"; for (int i = max; i &gt;= 0; --i) if (arr[i] != 0) &#123; cout &lt;&lt; arr[i] &lt;&lt;\"*x^\"&lt;&lt; i ; if(i!=0) cout&lt;&lt;\"+\"; &#125; return 0;&#125; 链表实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include &lt;limits.h&gt;#include &lt;math.h&gt;#include &lt;process.h&gt;using namespace std;typedef struct LNode&#123; int coef; int expn; struct LNode *next;&#125; LNode,*polynomail;void creatpolyn(polynomail &amp;p,int m)&#123; int i; int coef; int expn; polynomail s; p=(polynomail)malloc(sizeof(LNode)); p-&gt;next=NULL; for(i=1; i&lt;=m; ++i) &#123; s=(polynomail)malloc(sizeof(LNode)); cout&lt;&lt;\"请输入一元多项式的系数和指数:\"; cin&gt;&gt;coef&gt;&gt;expn; s-&gt;coef=coef; s-&gt;expn=expn; s-&gt;next=p-&gt;next; p-&gt;next=s; &#125;&#125;polynomail addpolyn(polynomail &amp;pa,polynomail &amp;pb)&#123; polynomail c,pc; pc=(polynomail)malloc(sizeof(LNode)); pc-&gt;next=NULL; pa=pa-&gt;next; pb=pb-&gt;next; while(pa &amp;&amp; pb) &#123; if((pa-&gt;expn)==(pb-&gt;expn)) &#123; c=(polynomail)malloc(sizeof(LNode)); c-&gt;expn=pa-&gt;expn; c-&gt;coef=((pa-&gt;coef)+(pb-&gt;coef)); pa=pa-&gt;next; pb=pb-&gt;next; &#125; else if((pa-&gt;expn)&gt;(pb-&gt;expn)) &#123; c=(polynomail)malloc(sizeof(LNode)); c-&gt;expn=pb-&gt;expn; c-&gt;coef=pb-&gt;coef; pb=pb-&gt;next; &#125; else &#123; c=(polynomail)malloc(sizeof(LNode)); c-&gt;expn=pa-&gt;expn; c-&gt;coef=pa-&gt;coef; pa=pa-&gt;next; &#125; c-&gt;next=pc-&gt;next; pc-&gt;next=c; &#125; if(!pa &amp;&amp; pb) &#123; while(c-&gt;next!=NULL) &#123; c=c-&gt;next; &#125; c-&gt;next=pb; &#125; if(!pb &amp;&amp; pa) &#123; while(c-&gt;next!=NULL) &#123; c=c-&gt;next; &#125; c-&gt;next=pa; &#125; return pc;&#125;void printpolyn(polynomail &amp;p)&#123; while(p-&gt;next!=NULL) &#123; p=p-&gt;next; cout&lt;&lt;p-&gt;coef&lt;&lt;\"*X^\"&lt;&lt;p-&gt;expn; if(p-&gt;next!=NULL) cout&lt;&lt;\"+\"; &#125;&#125;int main()&#123; int n,m; polynomail pa,pb,pc; cout&lt;&lt;\"请输入一元多项式S1的项数:\"; scanf(\"%d\",&amp;n); creatpolyn(pa,n); cout&lt;&lt;\"请输入一元多项式S2的项数:\"; scanf(\"%d\",&amp;m); creatpolyn(pb,m); pc=addpolyn(pa,pb); cout&lt;&lt;\"\\n结果是:S1+S2= \"; printpolyn(pc);&#125;","permalink":"http://yoursite.com/2018/11/16/多项式相加链表和线性表实现/","categories":[],"tags":[]},{"title":"从浏览器输入url到显示网页发生了什么（简要过程）","date":"2018-11-15T13:39:42.000Z","path":"2018/11/15/从浏览器输入url到显示网页发生了什么（简要过程）/","text":"1.输入url2.应用层dns对域名进行解析，现在本地找有没有相应的IP地址，如果有就返回，没有就请求上级dns3.应用层客户端发送http请求4.传输层传输报文5.网络层IP协议查询MAC地址6.数据发送到数据链路层，服务器接收数据7.服务器响应请求返回相应文件8.页面渲染","permalink":"http://yoursite.com/2018/11/15/从浏览器输入url到显示网页发生了什么（简要过程）/","categories":[],"tags":[]},{"title":"内存中堆、栈和静态存储区的用法","date":"2018-11-15T07:42:14.000Z","path":"2018/11/15/that/","text":"1.堆堆中存储的全部是对象，每个对象都包含一个与之对应的class，不存储基本类型和对象的引用。在java JVM中只有一个堆区，且该堆区被所有线程共享。堆一般由程序员进行分配和释放。2.栈栈中存储的是基础数据类型和自定义对象的引用，内存中由多个栈区，每个线程都拥有属于他自己的一个栈区，并且栈区中的所有成员都是私有的，不能被其他线程的其他栈所访问。栈分为三个部分：基本类型变量区，执行环境上下文，操作指令区。栈是由系统编译器自行分配的。3.静态存储区存储所有的class和static变量，包含的都是程序中永远唯一的元素，他跟堆一样也是被所有线程所共享的。全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域中，未初始化的全局变量和静态变量在相邻的一块区域最有效率算2*8应该是移位运算吧，2左移三位？2&lt;&lt;3，这样应该不会占内存","permalink":"http://yoursite.com/2018/11/15/that/","categories":[],"tags":[]},{"title":"java关键字static、final、this、super总结","date":"2018-11-15T07:41:05.000Z","path":"2018/11/15/java关键字static、final、this、super总结/","text":"用static声明一个变量或方法，表示它是静态的，在之后可以对变量进行改变或者对静态方法进行重写，但是final表示最终的，由final声明的变量不能被重新赋值，方法不能被重写重构，final类不能被其他类所继承。 this和super一般在构造方法中比较常用(this一般用在该类的方法或者构造函数当中，而super一般用在一个继承了其他类的子类的方法或者构造方法中)，this可以调用该类的成员变量或者成员方法，并且可以在方法的任何位置使用，而super则是能对该类的父类的成员变量或方法进行调用，并且要调用super关键字必须在每个方法中的第一行进行调用","permalink":"http://yoursite.com/2018/11/15/java关键字static、final、this、super总结/","categories":[],"tags":[]},{"title":"Hello World","date":"2018-11-11T02:54:32.953Z","path":"2018/11/11/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","permalink":"http://yoursite.com/2018/11/11/hello-world/","categories":[],"tags":[]}]}